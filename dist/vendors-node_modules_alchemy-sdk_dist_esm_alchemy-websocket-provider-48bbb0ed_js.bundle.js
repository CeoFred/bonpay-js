(self["webpackChunkblockmoney"] = self["webpackChunkblockmoney"] || []).push([["vendors-node_modules_alchemy-sdk_dist_esm_alchemy-websocket-provider-48bbb0ed_js"],{

/***/ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketProvider": () => (/* binding */ WebSocketProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");
/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ws */ "./node_modules/@ethersproject/providers/lib.esm/ws.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */
let NextId = 1;
// For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub
class WebSocketProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {
    constructor(url, network) {
        // This will be added in the future; please open an issue to expedite
        if (network === "any") {
            logger.throwError("WebSocketProvider does not support 'any' network yet", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "network:any"
            });
        }
        if (typeof (url) === "string") {
            super(url, network);
        }
        else {
            super("_websocket", network);
        }
        this._pollingInterval = -1;
        this._wsReady = false;
        if (typeof (url) === "string") {
            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_websocket", new _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket(this.connection.url));
        }
        else {
            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_websocket", url);
        }
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_requests", {});
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_subs", {});
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_subIds", {});
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_detectNetwork", super.detectNetwork());
        // Stall sending requests until the socket is open...
        this.websocket.onopen = () => {
            this._wsReady = true;
            Object.keys(this._requests).forEach((id) => {
                this.websocket.send(this._requests[id].payload);
            });
        };
        this.websocket.onmessage = (messageEvent) => {
            const data = messageEvent.data;
            const result = JSON.parse(data);
            if (result.id != null) {
                const id = String(result.id);
                const request = this._requests[id];
                delete this._requests[id];
                if (result.result !== undefined) {
                    request.callback(null, result.result);
                    this.emit("debug", {
                        action: "response",
                        request: JSON.parse(request.payload),
                        response: result.result,
                        provider: this
                    });
                }
                else {
                    let error = null;
                    if (result.error) {
                        error = new Error(result.error.message || "unknown error");
                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, "code", result.error.code || null);
                        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, "response", data);
                    }
                    else {
                        error = new Error("unknown error");
                    }
                    request.callback(error, undefined);
                    this.emit("debug", {
                        action: "response",
                        error: error,
                        request: JSON.parse(request.payload),
                        provider: this
                    });
                }
            }
            else if (result.method === "eth_subscription") {
                // Subscription...
                const sub = this._subs[result.params.subscription];
                if (sub) {
                    //this.emit.apply(this,                  );
                    sub.processFunc(result.params.result);
                }
            }
            else {
                console.warn("this should not happen");
            }
        };
        // This Provider does not actually poll, but we want to trigger
        // poll events for things that depend on them (like stalling for
        // block and transaction lookups)
        const fauxPoll = setInterval(() => {
            this.emit("poll");
        }, 1000);
        if (fauxPoll.unref) {
            fauxPoll.unref();
        }
    }
    // Cannot narrow the type of _websocket, as that is not backwards compatible
    // so we add a getter and let the WebSocket be a public API.
    get websocket() { return this._websocket; }
    detectNetwork() {
        return this._detectNetwork;
    }
    get pollingInterval() {
        return 0;
    }
    resetEventsBlock(blockNumber) {
        logger.throwError("cannot reset events block on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resetEventBlock"
        });
    }
    set pollingInterval(value) {
        logger.throwError("cannot set polling interval on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    set polling(value) {
        if (!value) {
            return;
        }
        logger.throwError("cannot set polling on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
        });
    }
    send(method, params) {
        const rid = NextId++;
        return new Promise((resolve, reject) => {
            function callback(error, result) {
                if (error) {
                    return reject(error);
                }
                return resolve(result);
            }
            const payload = JSON.stringify({
                method: method,
                params: params,
                id: rid,
                jsonrpc: "2.0"
            });
            this.emit("debug", {
                action: "request",
                request: JSON.parse(payload),
                provider: this
            });
            this._requests[String(rid)] = { callback, payload };
            if (this._wsReady) {
                this.websocket.send(payload);
            }
        });
    }
    static defaultUrl() {
        return "ws:/\/localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
        return __awaiter(this, void 0, void 0, function* () {
            let subIdPromise = this._subIds[tag];
            if (subIdPromise == null) {
                subIdPromise = Promise.all(param).then((param) => {
                    return this.send("eth_subscribe", param);
                });
                this._subIds[tag] = subIdPromise;
            }
            const subId = yield subIdPromise;
            this._subs[subId] = { tag, processFunc };
        });
    }
    _startEvent(event) {
        switch (event.type) {
            case "block":
                this._subscribe("block", ["newHeads"], (result) => {
                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(result.number).toNumber();
                    this._emitted.block = blockNumber;
                    this.emit("block", blockNumber);
                });
                break;
            case "pending":
                this._subscribe("pending", ["newPendingTransactions"], (result) => {
                    this.emit("pending", result);
                });
                break;
            case "filter":
                this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
                    if (result.removed == null) {
                        result.removed = false;
                    }
                    this.emit(event.filter, this.formatter.filterLog(result));
                });
                break;
            case "tx": {
                const emitReceipt = (event) => {
                    const hash = event.hash;
                    this.getTransactionReceipt(hash).then((receipt) => {
                        if (!receipt) {
                            return;
                        }
                        this.emit(hash, receipt);
                    });
                };
                // In case it is already mined
                emitReceipt(event);
                // To keep things simple, we start up a single newHeads subscription
                // to keep an eye out for transactions we are watching for.
                // Starting a subscription for an event (i.e. "tx") that is already
                // running is (basically) a nop.
                this._subscribe("tx", ["newHeads"], (result) => {
                    this._events.filter((e) => (e.type === "tx")).forEach(emitReceipt);
                });
                break;
            }
            // Nothing is needed
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
                break;
            default:
                console.log("unhandled:", event);
                break;
        }
    }
    _stopEvent(event) {
        let tag = event.tag;
        if (event.type === "tx") {
            // There are remaining transaction event listeners
            if (this._events.filter((e) => (e.type === "tx")).length) {
                return;
            }
            tag = "tx";
        }
        else if (this.listenerCount(event.event)) {
            // There are remaining event listeners
            return;
        }
        const subId = this._subIds[tag];
        if (!subId) {
            return;
        }
        delete this._subIds[tag];
        subId.then((subId) => {
            if (!this._subs[subId]) {
                return;
            }
            delete this._subs[subId];
            this.send("eth_unsubscribe", [subId]);
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            // Wait until we have connected before trying to disconnect
            if (this.websocket.readyState === _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket.CONNECTING) {
                yield (new Promise((resolve) => {
                    this.websocket.onopen = function () {
                        resolve(true);
                    };
                    this.websocket.onerror = function () {
                        resolve(false);
                    };
                }));
            }
            // Hangup
            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
            this.websocket.close(1000);
        });
    }
}
//# sourceMappingURL=websocket-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/ws.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ws.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocket": () => (/* binding */ WS)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");



let WS = null;
try {
    WS = WebSocket;
    if (WS == null) {
        throw new Error("inject please");
    }
}
catch (error) {
    const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
    WS = function () {
        logger.throwError("WebSockets not supported in this environment", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new WebSocket()"
        });
    };
}
//export default WS;
//module.exports = WS;

//# sourceMappingURL=ws.js.map

/***/ }),

/***/ "./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-48bbb0ed.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-48bbb0ed.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlchemyWebSocketProvider": () => (/* binding */ AlchemyWebSocketProvider),
/* harmony export */   "getAlchemyEventTag": () => (/* binding */ getAlchemyEventTag)
/* harmony export */ });
/* harmony import */ var _index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index-6bca930a.js */ "./node_modules/alchemy-sdk/dist/esm/index-6bca930a.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _alchemy_provider_faa5d8b1_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./alchemy-provider-faa5d8b1.js */ "./node_modules/alchemy-sdk/dist/esm/alchemy-provider-faa5d8b1.js");
/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ "./node_modules/sturdy-websocket/dist/index.js");
/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/providers */ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js");
/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/networks */ "./node_modules/@ethersproject/networks/lib.esm/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_1__);













/**
 * The maximum number of blocks to backfill. If more than this many blocks have
 * been missed, then we'll sadly miss data, but we want to make sure we don't
 * end up requesting thousands of blocks if somebody left their laptop closed for a week.
 */
const MAX_BACKFILL_BLOCKS = 120;
/**
 * The WebsocketBackfiller fetches events that were sent since a provided block
 * number. This is used in the {@link AlchemyWebSocketProvider} to backfill
 * events that were transmitted while the websocket connection was down.
 *
 * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.
 *
 * @internal
 */
class WebsocketBackfiller {
    constructor(provider) {
        this.provider = provider;
        // TODO: Use HTTP provider to do backfill.
        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;
    }
    /**
     * Runs backfill for `newHeads` events.
     *
     * @param isCancelled Whether the backfill request is cancelled.
     * @param previousHeads Previous head requests that were sent.
     * @param fromBlockNumber The block number to start backfilling from.
     * @returns A list of `newHeads` events that were sent since the last backfill.
     */
    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            throwIfCancelled(isCancelled);
            const toBlockNumber = yield this.getBlockNumber();
            throwIfCancelled(isCancelled);
            // If there are no previous heads to fetch, return new heads since
            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.
            if (previousHeads.length === 0) {
                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);
            }
            // If the last emitted event is too far back in the past, there's no need
            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of
            // new heads.
            const lastSeenBlockNumber = (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousHeads[previousHeads.length - 1].number);
            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;
            if (lastSeenBlockNumber <= minBlockNumber) {
                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);
            }
            // To capture all `newHeads` events, return all head events from the last
            // seen block number to current + any of the previous heads that were re-orged.
            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);
            throwIfCancelled(isCancelled);
            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);
            throwIfCancelled(isCancelled);
            return [...reorgHeads, ...intermediateHeads];
        });
    }
    /**
     * Runs backfill for `logs` events.
     *
     * @param isCancelled Whether the backfill request is cancelled.
     * @param filter The filter object that accompanies a logs subscription.
     * @param previousLogs Previous log requests that were sent.
     * @param fromBlockNumber The block number to start backfilling from.
     */
    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            throwIfCancelled(isCancelled);
            const toBlockNumber = yield this.getBlockNumber();
            throwIfCancelled(isCancelled);
            // If there are no previous logs to fetch, return new logs since
            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.
            if (previousLogs.length === 0) {
                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);
            }
            // If the last emitted log is too far back in the past, there's no need
            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`
            // worth of logs.
            const lastSeenBlockNumber = (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[previousLogs.length - 1].blockNumber);
            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;
            if (lastSeenBlockNumber < minBlockNumber) {
                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);
            }
            // Return all log events that have happened along with log events that have
            // been removed due to a chain reorg.
            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);
            throwIfCancelled(isCancelled);
            // All previous logs with a block number greater than the common ancestor
            // were part of a re-org, so mark them as such.
            const removedLogs = previousLogs
                .filter(log => (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.blockNumber) > commonAncestor.blockNumber)
                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));
            // If no common ancestor was found, start backfill from the oldest log's
            // block number.
            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY
                ? (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[0].blockNumber)
                : commonAncestor.blockNumber;
            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);
            // De-dupe any logs that were already emitted.
            addedLogs = addedLogs.filter(log => log &&
                ((0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.blockNumber) > commonAncestor.blockNumber ||
                    (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(log.logIndex) > commonAncestor.logIndex));
            throwIfCancelled(isCancelled);
            return [...removedLogs, ...addedLogs];
        });
    }
    /**
     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.
     *
     * @internal
     */
    setMaxBackfillBlock(newMax) {
        this.maxBackfillBlocks = newMax;
    }
    /**
     * Gets the current block number as a number.
     *
     * @private
     */
    getBlockNumber() {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            const blockNumberHex = yield this.provider.send('eth_blockNumber');
            return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(blockNumberHex);
        });
    }
    /**
     * Gets all `newHead` events in the provided range. Note that the returned
     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads
     * that were part of a re-org.
     *
     * @private
     */
    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            if (fromBlockInclusive >= toBlockExclusive) {
                return [];
            }
            const batchParts = [];
            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {
                batchParts.push({
                    method: 'eth_getBlockByNumber',
                    params: [(0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.t)(i), false]
                });
            }
            // TODO: just fire off each send() separately since we're no longer batching:
            // TODO: handle errors
            const batchedBlockHeads = yield this.provider.sendBatch(batchParts);
            const blockHeads = batchedBlockHeads.reduce((acc, batch) => acc.concat(batch), []);
            return blockHeads.map(toNewHeadsEvent);
        });
    }
    /**
     * Returns all heads that were part of a reorg event.
     *
     * @private
     */
    getReorgHeads(isCancelled, previousHeads) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            const result = [];
            // Iterate from the most recent head backwards in order to find the first
            // block that was part of a re-org.
            for (let i = previousHeads.length - 1; i >= 0; i--) {
                const oldEvent = previousHeads[i];
                const blockHead = yield this.getBlockByNumber((0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldEvent.number));
                throwIfCancelled(isCancelled);
                // If the hashes match, then current head in the iteration was not re-orged.
                if (oldEvent.hash === blockHead.hash) {
                    break;
                }
                result.push(toNewHeadsEvent(blockHead));
            }
            return result.reverse();
        });
    }
    /**
     * Simple wrapper around `eth_getBlockByNumber` that returns the complete
     * block information for the provided block number.
     *
     * @private
     */
    getBlockByNumber(blockNumber) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            return this.provider.send('eth_getBlockByNumber', [
                (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.t)(blockNumber),
                false
            ]);
        });
    }
    /**
     * Given a list of previous log events, finds the common block number from the
     * logs that matches the block head.
     *
     * This can be used to identify which logs are part of a re-org.
     *
     * Returns 1 less than the oldest log's block number if no common ancestor was found.
     *
     * @private
     */
    getCommonAncestor(isCancelled, previousLogs) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            // Iterate from the most recent head backwards in order to find the first
            // block that was part of a re-org.
            let blockHead = yield this.getBlockByNumber((0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(previousLogs[previousLogs.length - 1].blockNumber));
            throwIfCancelled(isCancelled);
            for (let i = previousLogs.length - 1; i >= 0; i--) {
                const oldLog = previousLogs[i];
                // Ensure that updated blocks are fetched every time the log's block number
                // changes.
                if (oldLog.blockNumber !== blockHead.number) {
                    blockHead = yield this.getBlockByNumber((0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.blockNumber));
                }
                // Since logs are ordered in ascending order, the first log that matches
                // the hash should be the largest logIndex.
                if (oldLog.blockHash === blockHead.hash) {
                    return {
                        blockNumber: (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.blockNumber),
                        logIndex: (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(oldLog.logIndex)
                    };
                }
            }
            return {
                blockNumber: Number.NEGATIVE_INFINITY,
                logIndex: Number.NEGATIVE_INFINITY
            };
        });
    }
    /**
     * Gets all `logs` events in the provided range. Note that the returned logs
     * do not include removed logs.
     *
     * @private
     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            if (fromBlockInclusive >= toBlockExclusive) {
                return [];
            }
            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.t)(fromBlockInclusive), toBlock: (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.t)(toBlockExclusive - 1) });
            return this.provider.send('eth_getLogs', [rangeFilter]);
        });
    }
}
function toNewHeadsEvent(head) {
    const result = Object.assign({}, head);
    delete result.totalDifficulty;
    delete result.transactions;
    delete result.uncles;
    return result;
}
function dedupeNewHeads(events) {
    return dedupe(events, event => event.hash);
}
function dedupeLogs(events) {
    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);
}
function dedupe(items, getKey) {
    const keysSeen = new Set();
    const result = [];
    items.forEach(item => {
        const key = getKey(item);
        if (!keysSeen.has(key)) {
            keysSeen.add(key);
            result.push(item);
        }
    });
    return result;
}
const CANCELLED = new Error('Cancelled');
function throwIfCancelled(isCancelled) {
    if (isCancelled()) {
        throw CANCELLED;
    }
}

/**
 * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to
 * ethers events.
 */
const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE = 'alchemy-pending-transactions';
/** Method name for Alchemy pending transaction subscriptions when using Websockets. */
const ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD = 'alchemy_pendingTransactions';
/**
 * DO NOT MODIFY.
 *
 * Event class copied directly over from ethers.js's `BaseProvider` class.
 *
 * This class is used to represent events and their corresponding listeners. The
 * SDK needs to extend this class in order to support Alchemy's custom
 * Subscription API types. The original class is not exported by ethers. Minimal
 * changes have been made in order to get TS to compile.
 */
class Event {
    constructor(tag, listener, once) {
        this.listener = listener;
        this.tag = tag;
        this.once = once;
        this._lastBlockNumber = -2;
        this._inflight = false;
    }
    get event() {
        switch (this.type) {
            case 'tx':
                return this.hash;
            case 'filter':
                return this.filter;
            default:
                return this.tag;
        }
    }
    get type() {
        return this.tag.split(':')[0];
    }
    get hash() {
        const comps = this.tag.split(':');
        if (comps[0] !== 'tx') {
            throw new Error('Not a transaction event');
        }
        return comps[1];
    }
    get filter() {
        const comps = this.tag.split(':');
        if (comps[0] !== 'filter') {
            throw new Error('Not a transaction event');
        }
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) {
            filter.topics = topics;
        }
        if (address && address !== '*') {
            filter.address = address;
        }
        return filter;
    }
    pollable() {
        const PollableEvents = ['block', 'network', 'pending', 'poll'];
        return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;
    }
}
/**
 * Wrapper class around the ethers `Event` class in order to add support for
 * Alchemy's custom subscriptions types.
 *
 * The getters on this class deserialize the event tag generated by
 * {@link getAlchemyEventTag} into the original fields passed into the event.
 */
class EthersEvent extends Event {
    /**
     * Converts the event tag into the original `fromAddress` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get fromAddress() {
        const comps = this.tag.split(':');
        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
            return undefined;
        }
        if (comps[1] && comps[1] !== '*') {
            return deserializeAddressField(comps[1]);
        }
        else {
            return undefined;
        }
    }
    /**
     * Converts the event tag into the original `toAddress` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get toAddress() {
        const comps = this.tag.split(':');
        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
            return undefined;
        }
        if (comps[2] && comps[2] !== '*') {
            return deserializeAddressField(comps[2]);
        }
        else {
            return undefined;
        }
    }
    /**
     * Converts the event tag into the original `hashesOnly` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get hashesOnly() {
        const comps = this.tag.split(':');
        if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
            return undefined;
        }
        if (comps[3] && comps[3] !== '*') {
            return comps[3] === 'true';
        }
        else {
            return undefined;
        }
    }
}
function deserializeTopics(data) {
    if (data === '') {
        return [];
    }
    return data.split(/&/g).map(topic => {
        if (topic === '') {
            return [];
        }
        const comps = topic.split('|').map(topic => {
            return topic === 'null' ? null : topic;
        });
        return comps.length === 1 ? comps[0] : comps;
    });
}
function deserializeAddressField(data) {
    if (data === '') {
        return undefined;
    }
    const addresses = data.split('|');
    return addresses.length === 1 ? addresses[0] : addresses;
}

const HEARTBEAT_INTERVAL = 30000;
const HEARTBEAT_WAIT_TIME = 10000;
const BACKFILL_TIMEOUT = 60000;
const BACKFILL_RETRIES = 5;
/**
 * Subscriptions have a memory of recent events they have sent so that in the
 * event that they disconnect and need to backfill, they can detect re-orgs.
 * Keep a buffer that goes back at least these many blocks, the maximum amount
 * at which we might conceivably see a re-org.
 *
 * Note that while our buffer goes back this many blocks, it may contain more
 * than this many elements, since in the case of logs subscriptions more than
 * one event may be emitted for a block.
 */
const RETAINED_EVENT_BLOCK_COUNT = 10;
/**
 * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.
 *
 * Do not call this constructor directly. Instead, instantiate an instance of
 * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.
 *
 * @public
 */
class AlchemyWebSocketProvider extends _ethersproject_providers__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider {
    /** @internal */
    constructor(config, wsConstructor) {
        var _a;
        // Normalize the API Key to a string.
        const apiKey = _alchemy_provider_faa5d8b1_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getApiKey(config.apiKey);
        // Generate our own connection info with the correct endpoint URLs.
        const alchemyNetwork = _alchemy_provider_faa5d8b1_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getAlchemyNetwork(config.network);
        const connection = _alchemy_provider_faa5d8b1_js__WEBPACK_IMPORTED_MODULE_4__.AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');
        const protocol = `alchemy-sdk-${_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.V}`;
        // Use the provided config URL override if it exists, otherwise use the created one.
        const ws = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__["default"]((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {
            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()
        });
        // Normalize the Alchemy named network input to the network names used by
        // ethers. This allows the parent super constructor in JsonRpcProvider to
        // correctly set the network.
        const ethersNetwork = _index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.E[alchemyNetwork];
        super(ws, ethersNetwork);
        this._events = [];
        // In the case of a WebSocket reconnection, all subscriptions are lost and we
        // create new ones to replace them, but we want to create the illusion that
        // the original subscriptions persist. Thus, maintain a mapping from the
        // "virtual" subscription ids which are visible to the consumer to the
        // "physical" subscription ids of the actual connections. This terminology is
        // borrowed from virtual and physical memory, which has a similar mapping.
        /** @internal */
        this.virtualSubscriptionsById = new Map();
        /** @internal */
        this.virtualIdsByPhysicalId = new Map();
        /**
         * The underlying ethers {@link WebSocketProvider} already handles and emits
         * messages. To allow backfilling, track all messages that are emitted.
         *
         * This is a field arrow function in order to preserve `this` context when
         * passing the method as an event listener.
         *
         * @internal
         */
        this.handleMessage = (event) => {
            const message = JSON.parse(event.data);
            if (!isSubscriptionEvent(message)) {
                return;
            }
            const physicalId = message.params.subscription;
            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);
            if (!virtualId) {
                return;
            }
            const subscription = this.virtualSubscriptionsById.get(virtualId);
            if (subscription.method !== 'eth_subscribe') {
                return;
            }
            switch (subscription.params[0]) {
                case 'newHeads': {
                    const newHeadsSubscription = subscription;
                    const newHeadsMessage = message;
                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;
                    const { result } = newHeadsMessage.params;
                    if (isBackfilling) {
                        addToNewHeadsEventsBuffer(backfillBuffer, result);
                    }
                    else if (physicalId !== virtualId) {
                        // In the case of a re-opened subscription, ethers will not emit the
                        // event, so the SDK has to.
                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);
                    }
                    else {
                        // Ethers subscription mapping will emit the event, just store it.
                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);
                    }
                    break;
                }
                case 'logs': {
                    const logsSubscription = subscription;
                    const logsMessage = message;
                    const { isBackfilling, backfillBuffer } = logsSubscription;
                    const { result } = logsMessage.params;
                    if (isBackfilling) {
                        addToLogsEventsBuffer(backfillBuffer, result);
                    }
                    else if (virtualId !== physicalId) {
                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);
                    }
                    else {
                        this.rememberEvent(virtualId, result, getLogsBlockNumber);
                    }
                    break;
                }
            }
        };
        /**
         * When the websocket connection reopens:
         *
         * 1. Resubscribe to all existing subscriptions and start backfilling
         * 2. Restart heart beat.
         *
         * This is a field arrow function in order to preserve `this` context when
         * passing the method as an event listener.
         *
         * @internal
         */
        this.handleReopen = () => {
            this.virtualIdsByPhysicalId.clear();
            const { cancel, isCancelled } = makeCancelToken();
            this.cancelBackfill = cancel;
            for (const subscription of this.virtualSubscriptionsById.values()) {
                void (() => (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
                    try {
                        yield this.resubscribeAndBackfill(isCancelled, subscription);
                    }
                    catch (error) {
                        if (!isCancelled()) {
                            console.error(`Error while backfilling "${subscription.params[0]}" subscription. Some events may be missing.`, error);
                        }
                    }
                }))();
            }
            this.startHeartbeat();
        };
        /**
         * Cancels the heartbeat and any pending backfills being performed. This is
         * called when the websocket connection goes down or is disconnected.
         *
         * This is a field arrow function in order to preserve `this` context when
         * passing the method as an event listener.
         *
         * @internal
         */
        this.stopHeartbeatAndBackfill = () => {
            if (this.heartbeatIntervalId != null) {
                clearInterval(this.heartbeatIntervalId);
                this.heartbeatIntervalId = undefined;
            }
            this.cancelBackfill();
        };
        this.apiKey = apiKey;
        // Start heartbeat and backfiller for the websocket connection.
        this.backfiller = new WebsocketBackfiller(this);
        this.addSocketListeners();
        this.startHeartbeat();
        this.cancelBackfill = _index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.n;
    }
    /**
     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.
     *
     * This override allows the SDK to set the provider's network to values not
     * yet supported by ethers.js.
     *
     * @internal
     * @override
     */
    static getNetwork(network) {
        if (typeof network === 'string' && network in _index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.C) {
            return _index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.C[network];
        }
        // Call the standard ethers.js getNetwork method for other networks.
        return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_5__.getNetwork)(network);
    }
    /**
     * Overridden implementation of ethers that includes Alchemy based subscriptions.
     *
     * @param eventName Event to subscribe to
     * @param listener The listener function to call when the event is triggered.
     * @override
     * @public
     */
    // TODO: Override `Listener` type to get type autocompletions.
    on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
    }
    /**
     * Overridden implementation of ethers that includes Alchemy based
     * subscriptions. Adds a listener to the triggered for only the next
     * {@link eventName} event, after which it will be removed.
     *
     * @param eventName Event to subscribe to
     * @param listener The listener function to call when the event is triggered.
     * @override
     * @public
     */
    // TODO: Override `Listener` type to get type autocompletions.
    once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
    }
    /**
     * Removes the provided {@link listener} for the {@link eventName} event. If no
     * listener is provided, all listeners for the event will be removed.
     *
     * @param eventName Event to unlisten to.
     * @param listener The listener function to remove.
     * @override
     * @public
     */
    off(eventName, listener) {
        if (isAlchemyEvent(eventName)) {
            return this._off(eventName, listener);
        }
        else {
            return super.off(eventName, listener);
        }
    }
    /**
     * Remove all listeners for the provided {@link eventName} event. If no event
     * is provided, all events and their listeners are removed.
     *
     * @param eventName The event to remove all listeners for.
     * @override
     * @public
     */
    removeAllListeners(eventName) {
        if (eventName !== undefined && isAlchemyEvent(eventName)) {
            return this._removeAllListeners(eventName);
        }
        else {
            return super.removeAllListeners(eventName);
        }
    }
    /**
     * Returns the number of listeners for the provided {@link eventName} event. If
     * no event is provided, the total number of listeners for all events is returned.
     *
     * @param eventName The event to get the number of listeners for.
     * @public
     * @override
     */
    listenerCount(eventName) {
        if (eventName !== undefined && isAlchemyEvent(eventName)) {
            return this._listenerCount(eventName);
        }
        else {
            return super.listenerCount(eventName);
        }
    }
    /**
     * Returns an array of listeners for the provided {@link eventName} event. If
     * no event is provided, all listeners will be included.
     *
     * @param eventName The event to get the listeners for.
     * @public
     * @override
     */
    listeners(eventName) {
        if (eventName !== undefined && isAlchemyEvent(eventName)) {
            return this._listeners(eventName);
        }
        else {
            return super.listeners(eventName);
        }
    }
    /**
     * Overrides the method in `BaseProvider` in order to properly format the
     * Alchemy subscription events.
     *
     * @internal
     * @override
     */
    _addEventListener(eventName, listener, once) {
        if (isAlchemyEvent(eventName)) {
            verifyAlchemyEventName(eventName);
            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);
            this._events.push(event);
            this._startEvent(event);
            return this;
        }
        else {
            return super._addEventListener(eventName, listener, once);
        }
    }
    /**
     * Overrides the `_startEvent()` method in ethers.js's
     * {@link WebSocketProvider} to include additional alchemy methods.
     *
     * @param event
     * @override
     * @internal
     */
    _startEvent(event) {
        // Check if the event type is a custom Alchemy subscription.
        const customLogicTypes = [
            ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,
            'block',
            'filter'
        ];
        if (customLogicTypes.includes(event.type)) {
            this.customStartEvent(event);
        }
        else {
            super._startEvent(event);
        }
    }
    /**
     * Overridden from ethers.js's {@link WebSocketProvider}
     *
     * Modified in order to add mappings for backfilling.
     *
     * @internal
     * @override
     */
    _subscribe(tag, param, processFunc, event) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            let subIdPromise = this._subIds[tag];
            // BEGIN MODIFIED CODE
            const startingBlockNumber = yield this.getBlockNumber();
            // END MODIFIED CODE
            if (subIdPromise == null) {
                subIdPromise = Promise.all(param).then(param => {
                    return this.send('eth_subscribe', param);
                });
                this._subIds[tag] = subIdPromise;
            }
            const subId = yield subIdPromise;
            // BEGIN MODIFIED CODE
            const resolvedParams = yield Promise.all(param);
            this.virtualSubscriptionsById.set(subId, {
                event: event,
                method: 'eth_subscribe',
                params: resolvedParams,
                startingBlockNumber,
                virtualId: subId,
                physicalId: subId,
                sentEvents: [],
                isBackfilling: false,
                backfillBuffer: []
            });
            this.virtualIdsByPhysicalId.set(subId, subId);
            // END MODIFIED CODE
            this._subs[subId] = { tag, processFunc };
        });
    }
    /**
     * DO NOT MODIFY.
     *
     * Original code copied over from ether.js's `BaseProvider`.
     *
     * This method is copied over directly in order to implement Alchemy's unique
     * subscription types. The only difference is that this method calls
     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
     * order to parse the Alchemy subscription event.
     *
     * @internal
     * @override
     */
    emit(eventName, ...args) {
        if (isAlchemyEvent(eventName)) {
            let result = false;
            const stopped = [];
            // This line is the only modified line from the original method.
            const eventTag = getAlchemyEventTag(eventName);
            this._events = this._events.filter(event => {
                if (event.tag !== eventTag) {
                    return true;
                }
                setTimeout(() => {
                    event.listener.apply(this, args);
                }, 0);
                result = true;
                if (event.once) {
                    stopped.push(event);
                    return false;
                }
                return true;
            });
            stopped.forEach(event => {
                this._stopEvent(event);
            });
            return result;
        }
        else {
            return super.emit(eventName, ...args);
        }
    }
    /** @internal */
    sendBatch(parts) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            let nextId = 0;
            const payload = parts.map(({ method, params }) => {
                return {
                    method,
                    params,
                    jsonrpc: '2.0',
                    id: `alchemy-sdk:${nextId++}`
                };
            });
            const response = yield this.sendBatchConcurrently(payload);
            const errorResponse = response.find(r => !!r.error);
            if (errorResponse) {
                throw new Error(errorResponse.error.message);
            }
            // The ids are ascending numbers because that's what Payload Factories do.
            return response
                .sort((r1, r2) => r1.id - r2.id)
                .map(r => r.result);
        });
    }
    /** @override */
    destroy() {
        this.removeSocketListeners();
        this.stopHeartbeatAndBackfill();
        return super.destroy();
    }
    /**
     * Overrides the ether's `isCommunityResource()` method. Returns true if the
     * current api key is the default key.
     *
     * @override
     */
    isCommunityResource() {
        return this.apiKey === _index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.D;
    }
    /**
     * DO NOT MODIFY.
     *
     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.
     *
     * This method is copied over directly in order to support Alchemy's
     * subscription type by allowing the provider to properly stop Alchemy's
     * subscription events.
     *
     * @internal
     */
    _stopEvent(event) {
        let tag = event.tag;
        // START MODIFIED CODE
        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
            // There are remaining pending transaction listeners.
            if (this._events.filter(e => e.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE).length) {
                return;
            }
            // END MODIFIED CODE
        }
        else if (event.type === 'tx') {
            // There are remaining transaction event listeners
            if (this._events.filter(e => e.type === 'tx').length) {
                return;
            }
            tag = 'tx';
        }
        else if (this.listenerCount(event.event)) {
            // There are remaining event listeners
            return;
        }
        const subId = this._subIds[tag];
        if (!subId) {
            return;
        }
        delete this._subIds[tag];
        void subId.then(subId => {
            if (!this._subs[subId]) {
                return;
            }
            delete this._subs[subId];
            void this.send('eth_unsubscribe', [subId]);
        });
    }
    /** @internal */
    addSocketListeners() {
        this._websocket.addEventListener('message', this.handleMessage);
        this._websocket.addEventListener('reopen', this.handleReopen);
        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);
    }
    /** @internal */
    removeSocketListeners() {
        this._websocket.removeEventListener('message', this.handleMessage);
        this._websocket.removeEventListener('reopen', this.handleReopen);
        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);
    }
    /**
     * Reopens the backfill based on
     *
     * @param isCancelled
     * @param subscription
     * @internal
     */
    resubscribeAndBackfill(isCancelled, subscription) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;
            subscription.isBackfilling = true;
            backfillBuffer.length = 0;
            try {
                const physicalId = yield this.send(method, params);
                throwIfCancelled(isCancelled);
                subscription.physicalId = physicalId;
                this.virtualIdsByPhysicalId.set(physicalId, virtualId);
                switch (params[0]) {
                    case 'newHeads': {
                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());
                        throwIfCancelled(isCancelled);
                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);
                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));
                        break;
                    }
                    case 'logs': {
                        const filter = params[1] || {};
                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());
                        throwIfCancelled(isCancelled);
                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);
                        events.forEach(event => this.emitLogsEvent(virtualId, event));
                        break;
                    }
                    default:
                        break;
                }
            }
            finally {
                subscription.isBackfilling = false;
                backfillBuffer.length = 0;
            }
        });
    }
    /** @internal */
    emitNewHeadsEvent(virtualId, result) {
        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);
    }
    /** @internal */
    emitLogsEvent(virtualId, result) {
        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);
    }
    /**
     * Emits an event to consumers, but also remembers it in its subscriptions's
     * `sentEvents` buffer so that we can detect re-orgs if the connection drops
     * and needs to be reconnected.
     *
     * @internal
     */
    emitAndRememberEvent(virtualId, result, getBlockNumber) {
        this.rememberEvent(virtualId, result, getBlockNumber);
        const subscription = this.virtualSubscriptionsById.get(virtualId);
        if (!subscription) {
            return;
        }
        this.emitGenericEvent(subscription, result);
    }
    /** @internal */
    rememberEvent(virtualId, result, getBlockNumber) {
        const subscription = this.virtualSubscriptionsById.get(virtualId);
        if (!subscription) {
            return;
        }
        // Web3 modifies these event objects once we pass them on (changing hex
        // numbers to numbers). We want the original event, so make a defensive
        // copy.
        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);
    }
    /** @internal */
    emitGenericEvent(subscription, result) {
        const emitFunction = this.emitProcessFn(subscription.event);
        emitFunction(result);
    }
    /**
     * Starts a heartbeat that pings the websocket server periodically to ensure
     * that the connection stays open.
     *
     * @internal
     */
    startHeartbeat() {
        if (this.heartbeatIntervalId != null) {
            return;
        }
        this.heartbeatIntervalId = setInterval(() => (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            try {
                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);
            }
            catch (_a) {
                this._websocket.reconnect();
            }
        }), HEARTBEAT_INTERVAL);
    }
    /**
     * This method sends the batch concurrently as individual requests rather than
     * as a batch, which was the original implementation. The original batch logic
     * is preserved in this implementation in order for faster porting.
     *
     * @param payload
     * @internal
     */
    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.
    // TODO(errors): Use allSettled() once we have more error handling.
    sendBatchConcurrently(payload) {
        return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
            return Promise.all(payload.map(req => this.send(req.method, req.params)));
        });
    }
    /** @internal */
    customStartEvent(event) {
        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {
            const { fromAddress, toAddress, hashesOnly } = event;
            void this._subscribe(event.tag, [
                ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD,
                { fromAddress, toAddress, hashesOnly }
            ], this.emitProcessFn(event), event);
        }
        else if (event.type === 'block') {
            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);
        }
        else if (event.type === 'filter') {
            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);
        }
    }
    /** @internal */
    emitProcessFn(event) {
        switch (event.type) {
            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:
                const { fromAddress, toAddress, hashesOnly } = event;
                return result => this.emit({
                    method: ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD,
                    fromAddress,
                    toAddress,
                    hashesOnly
                }, result);
            case 'block':
                return result => {
                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result.number).toNumber();
                    this._emitted.block = blockNumber;
                    this.emit('block', blockNumber);
                };
            case 'filter':
                return result => {
                    if (result.removed == null) {
                        result.removed = false;
                    }
                    this.emit(event.filter, this.formatter.filterLog(result));
                };
            default:
                throw new Error('Invalid event type to `emitProcessFn()`');
        }
    }
    /**
     * DO NOT MODIFY.
     *
     * Original code copied over from ether.js's `BaseProvider.off()`.
     *
     * This method is copied over directly in order to implement Alchemy's unique
     * subscription types. The only difference is that this method calls
     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
     * order to parse the Alchemy subscription event.
     *
     * @private
     */
    _off(eventName, listener) {
        if (listener == null) {
            return this.removeAllListeners(eventName);
        }
        const stopped = [];
        let found = false;
        const eventTag = getAlchemyEventTag(eventName);
        this._events = this._events.filter(event => {
            if (event.tag !== eventTag || event.listener != listener) {
                return true;
            }
            if (found) {
                return true;
            }
            found = true;
            stopped.push(event);
            return false;
        });
        stopped.forEach(event => {
            this._stopEvent(event);
        });
        return this;
    }
    /**
     * DO NOT MODIFY.
     *
     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.
     *
     * This method is copied over directly in order to implement Alchemy's unique
     * subscription types. The only difference is that this method calls
     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
     * order to parse the Alchemy subscription event.
     *
     * @private
     */
    _removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
            stopped = this._events;
            this._events = [];
        }
        else {
            const eventTag = getAlchemyEventTag(eventName);
            this._events = this._events.filter(event => {
                if (event.tag !== eventTag) {
                    return true;
                }
                stopped.push(event);
                return false;
            });
        }
        stopped.forEach(event => {
            this._stopEvent(event);
        });
        return this;
    }
    /**
     * DO NOT MODIFY.
     *
     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.
     *
     * This method is copied over directly in order to implement Alchemy's unique
     * subscription types. The only difference is that this method calls
     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
     * order to parse the Alchemy subscription event.
     *
     * @private
     */
    _listenerCount(eventName) {
        if (!eventName) {
            return this._events.length;
        }
        const eventTag = getAlchemyEventTag(eventName);
        return this._events.filter(event => {
            return event.tag === eventTag;
        }).length;
    }
    /**
     * DO NOT MODIFY.
     *
     * Original code copied over from ether.js's `BaseProvider.listeners()`.
     *
     * This method is copied over directly in order to implement Alchemy's unique
     * subscription types. The only difference is that this method calls
     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in
     * order to parse the Alchemy subscription event.
     *
     * @private
     */
    _listeners(eventName) {
        if (eventName == null) {
            return this._events.map(event => event.listener);
        }
        const eventTag = getAlchemyEventTag(eventName);
        return this._events
            .filter(event => event.tag === eventTag)
            .map(event => event.listener);
    }
}
function getWebsocketConstructor() {
    return isNodeEnvironment() ? (__webpack_require__(/*! websocket */ "./node_modules/websocket/lib/browser.js").w3cwebsocket) : WebSocket;
}
function isNodeEnvironment() {
    return (typeof process !== 'undefined' &&
        process != null &&
        process.versions != null &&
        process.versions.node != null);
}
// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.
function makeCancelToken() {
    let cancelled = false;
    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };
}
// TODO(cleanup): replace with SDK's backoff implementation
const MIN_RETRY_DELAY = 1000;
const RETRY_BACKOFF_FACTOR = 2;
const MAX_RETRY_DELAY = 30000;
function withBackoffRetries(f, retryCount, shouldRetry = () => true) {
    return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__._)(this, void 0, void 0, function* () {
        let nextWaitTime = 0;
        let i = 0;
        while (true) {
            try {
                return yield f();
            }
            catch (error) {
                i++;
                if (i >= retryCount || !shouldRetry(error)) {
                    throw error;
                }
                yield delay(nextWaitTime);
                if (!shouldRetry(error)) {
                    throw error;
                }
                nextWaitTime =
                    nextWaitTime === 0
                        ? MIN_RETRY_DELAY
                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);
            }
        }
    });
}
function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function withTimeout(promise, ms) {
    return Promise.race([
        promise,
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))
    ]);
}
function getNewHeadsBlockNumber(event) {
    return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(event.number);
}
function getLogsBlockNumber(event) {
    return (0,_index_6bca930a_js__WEBPACK_IMPORTED_MODULE_2__.f)(event.blockNumber);
}
function isResponse(message) {
    return (Array.isArray(message) ||
        (message.jsonrpc === '2.0' && message.id !== undefined));
}
function isSubscriptionEvent(message) {
    return !isResponse(message);
}
function addToNewHeadsEventsBuffer(pastEvents, event) {
    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);
}
function addToLogsEventsBuffer(pastEvents, event) {
    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);
}
/**
 * Adds a new event to an array of events, evicting any events which are so old
 * that they will no longer feasibly be part of a reorg.
 */
function addToPastEventsBuffer(pastEvents, event, getBlockNumber) {
    const currentBlockNumber = getBlockNumber(event);
    // Find first index of an event recent enough to retain, then drop everything
    // at a lower index.
    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);
    if (firstGoodIndex === -1) {
        pastEvents.length = 0;
    }
    else {
        pastEvents.splice(0, firstGoodIndex);
    }
    pastEvents.push(event);
}
function isAlchemyEvent(event) {
    return typeof event === 'object' && 'method' in event;
}
/**
 * Creates a string representation of an `alchemy_pendingTransaction`
 * subscription filter that is compatible with the ethers implementation of
 * `getEventTag()`. The method is not an exported function in ethers, which is
 * why the SDK has its own implementation.
 *
 * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.
 *
 * @example
 *   ```js
 *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'
 *   const eventTag =  getAlchemyEventTag(
 *   {
 *     "method": "alchemy_pendingTransaction",
 *     "fromAddress": "0xABC",
 *     "toAddress": ["0xDEF", "0xGHI"],
 *     "hashesOnly: true
 *   });
 *   ```;
 *
 * @param event
 * @internal
 */
function getAlchemyEventTag(event) {
    if (!isAlchemyEvent(event)) {
        throw new Error('Event tag requires AlchemyEventType');
    }
    const fromAddress = serializeAddressField(event.fromAddress);
    const toAddress = serializeAddressField(event.toAddress);
    const hashesOnly = serializeBooleanField(event.hashesOnly);
    return (ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE +
        ':' +
        fromAddress +
        ':' +
        toAddress +
        ':' +
        hashesOnly);
}
function serializeAddressField(field) {
    if (field === undefined) {
        return '*';
    }
    else if (Array.isArray(field)) {
        return field.join('|');
    }
    else {
        return field;
    }
}
function serializeBooleanField(field) {
    if (field === undefined) {
        return '*';
    }
    else {
        return field.toString();
    }
}
function verifyAlchemyEventName(eventName) {
    if (eventName.method !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD) {
        throw new Error(`Invalid method name ${eventName.method}. Accepted method names: ${ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD}`);
    }
}


//# sourceMappingURL=alchemy-websocket-provider-48bbb0ed.js.map


/***/ }),

/***/ "./node_modules/es5-ext/global.js":
/*!****************************************!*\
  !*** ./node_modules/es5-ext/global.js ***!
  \****************************************/
/***/ ((module) => {

var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

module.exports = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Fallback to standard globalThis if available
	if (typeof globalThis === "object" && globalThis) return globalThis;

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of updates to Object.prototype being restricted
		// via preventExtensions, seal or freeze
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ works, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();


/***/ }),

/***/ "./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var SHOULD_RECONNECT_FALSE_MESSAGE = "Provided shouldReconnect() returned false. Closing permanently.";
var SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = "Provided shouldReconnect() resolved to false. Closing permanently.";
var SturdyWebSocket = /** @class */ (function () {
    function SturdyWebSocket(url, protocolsOrOptions, options) {
        if (options === void 0) { options = {}; }
        this.url = url;
        this.onclose = null;
        this.onerror = null;
        this.onmessage = null;
        this.onopen = null;
        this.ondown = null;
        this.onreopen = null;
        this.CONNECTING = SturdyWebSocket.CONNECTING;
        this.OPEN = SturdyWebSocket.OPEN;
        this.CLOSING = SturdyWebSocket.CLOSING;
        this.CLOSED = SturdyWebSocket.CLOSED;
        this.hasBeenOpened = false;
        this.isClosed = false;
        this.messageBuffer = [];
        this.nextRetryTime = 0;
        this.reconnectCount = 0;
        this.lastKnownExtensions = "";
        this.lastKnownProtocol = "";
        this.listeners = {};
        if (protocolsOrOptions == null ||
            typeof protocolsOrOptions === "string" ||
            Array.isArray(protocolsOrOptions)) {
            this.protocols = protocolsOrOptions;
        }
        else {
            options = protocolsOrOptions;
        }
        this.options = applyDefaultOptions(options);
        if (!this.options.wsConstructor) {
            if (typeof WebSocket !== "undefined") {
                this.options.wsConstructor = WebSocket;
            }
            else {
                throw new Error("WebSocket not present in global scope and no " +
                    "wsConstructor option was provided.");
            }
        }
        this.openNewWebSocket();
    }
    Object.defineProperty(SturdyWebSocket.prototype, "binaryType", {
        get: function () {
            return this.binaryTypeInternal || "blob";
        },
        set: function (binaryType) {
            this.binaryTypeInternal = binaryType;
            if (this.ws) {
                this.ws.binaryType = binaryType;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SturdyWebSocket.prototype, "bufferedAmount", {
        get: function () {
            var sum = this.ws ? this.ws.bufferedAmount : 0;
            var hasUnknownAmount = false;
            this.messageBuffer.forEach(function (data) {
                var byteLength = getDataByteLength(data);
                if (byteLength != null) {
                    sum += byteLength;
                }
                else {
                    hasUnknownAmount = true;
                }
            });
            if (hasUnknownAmount) {
                this.debugLog("Some buffered data had unknown length. bufferedAmount()" +
                    " return value may be below the correct amount.");
            }
            return sum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SturdyWebSocket.prototype, "extensions", {
        get: function () {
            return this.ws ? this.ws.extensions : this.lastKnownExtensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SturdyWebSocket.prototype, "protocol", {
        get: function () {
            return this.ws ? this.ws.protocol : this.lastKnownProtocol;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SturdyWebSocket.prototype, "readyState", {
        get: function () {
            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;
        },
        enumerable: true,
        configurable: true
    });
    SturdyWebSocket.prototype.close = function (code, reason) {
        this.disposeSocket(code, reason);
        this.shutdown();
        this.debugLog("WebSocket permanently closed by client.");
    };
    SturdyWebSocket.prototype.send = function (data) {
        if (this.isClosed) {
            throw new Error("WebSocket is already in CLOSING or CLOSED state.");
        }
        else if (this.ws && this.ws.readyState === this.OPEN) {
            this.ws.send(data);
        }
        else {
            this.messageBuffer.push(data);
        }
    };
    SturdyWebSocket.prototype.reconnect = function () {
        if (this.isClosed) {
            throw new Error("Cannot call reconnect() on socket which is permanently closed.");
        }
        this.disposeSocket(1000, "Client requested reconnect.");
        this.handleClose(undefined);
    };
    SturdyWebSocket.prototype.addEventListener = function (type, listener) {
        if (!this.listeners[type]) {
            this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
    };
    SturdyWebSocket.prototype.dispatchEvent = function (event) {
        return this.dispatchEventOfType(event.type, event);
    };
    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {
        if (this.listeners[type]) {
            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });
        }
    };
    SturdyWebSocket.prototype.openNewWebSocket = function () {
        var _this = this;
        if (this.isClosed) {
            return;
        }
        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;
        this.debugLog("Opening new WebSocket to " + this.url + ".");
        var ws = new wsConstructor(this.url, this.protocols);
        ws.onclose = function (event) { return _this.handleClose(event); };
        ws.onerror = function (event) { return _this.handleError(event); };
        ws.onmessage = function (event) { return _this.handleMessage(event); };
        ws.onopen = function (event) { return _this.handleOpen(event); };
        this.connectTimeoutId = setTimeout(function () {
            // If this is running, we still haven't opened the websocket.
            // Kill it so we can try again.
            _this.clearConnectTimeout();
            _this.disposeSocket();
            _this.handleClose(undefined);
        }, connectTimeout);
        this.ws = ws;
    };
    SturdyWebSocket.prototype.handleOpen = function (event) {
        var _this = this;
        if (!this.ws || this.isClosed) {
            return;
        }
        var allClearResetTime = this.options.allClearResetTime;
        this.debugLog("WebSocket opened.");
        if (this.binaryTypeInternal != null) {
            this.ws.binaryType = this.binaryTypeInternal;
        }
        else {
            this.binaryTypeInternal = this.ws.binaryType;
        }
        this.clearConnectTimeout();
        if (this.hasBeenOpened) {
            this.dispatchEventOfType("reopen", event);
        }
        else {
            this.dispatchEventOfType("open", event);
            this.hasBeenOpened = true;
        }
        this.messageBuffer.forEach(function (message) { return _this.send(message); });
        this.messageBuffer = [];
        this.allClearTimeoutId = setTimeout(function () {
            _this.clearAllClearTimeout();
            _this.nextRetryTime = 0;
            _this.reconnectCount = 0;
            var openTime = (allClearResetTime / 1000) | 0;
            _this.debugLog("WebSocket remained open for " + openTime + " seconds. Resetting" +
                " retry time and count.");
        }, allClearResetTime);
    };
    SturdyWebSocket.prototype.handleMessage = function (event) {
        if (this.isClosed) {
            return;
        }
        this.dispatchEventOfType("message", event);
    };
    SturdyWebSocket.prototype.handleClose = function (event) {
        var _this = this;
        if (this.isClosed) {
            return;
        }
        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;
        this.clearConnectTimeout();
        this.clearAllClearTimeout();
        if (this.ws) {
            this.lastKnownExtensions = this.ws.extensions;
            this.lastKnownProtocol = this.ws.protocol;
            this.disposeSocket();
        }
        this.dispatchEventOfType("down", event);
        if (this.reconnectCount >= maxReconnectAttempts) {
            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());
            return;
        }
        var willReconnect = !event || shouldReconnect(event);
        if (typeof willReconnect === "boolean") {
            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);
        }
        else {
            willReconnect.then(function (willReconnectResolved) {
                if (_this.isClosed) {
                    return;
                }
                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);
            });
        }
    };
    SturdyWebSocket.prototype.handleError = function (event) {
        this.dispatchEventOfType("error", event);
        this.debugLog("WebSocket encountered an error.");
    };
    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {
        if (willReconnect) {
            this.reestablishConnection();
        }
        else {
            this.stopReconnecting(event, denialReason);
        }
    };
    SturdyWebSocket.prototype.reestablishConnection = function () {
        var _this = this;
        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;
        this.reconnectCount++;
        var retryTime = this.nextRetryTime;
        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));
        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);
        var retryTimeSeconds = (retryTime / 1000) | 0;
        this.debugLog("WebSocket was closed. Re-opening in " + retryTimeSeconds + " seconds.");
    };
    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {
        this.debugLog(debugReason);
        this.shutdown();
        if (event) {
            this.dispatchEventOfType("close", event);
        }
    };
    SturdyWebSocket.prototype.shutdown = function () {
        this.isClosed = true;
        this.clearAllTimeouts();
        this.messageBuffer = [];
        this.disposeSocket();
    };
    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {
        if (!this.ws) {
            return;
        }
        // Use noop handlers instead of null because some WebSocket
        // implementations, such as the one from isomorphic-ws, raise a stink on
        // unhandled events.
        this.ws.onerror = noop;
        this.ws.onclose = noop;
        this.ws.onmessage = noop;
        this.ws.onopen = noop;
        this.ws.close(closeCode, reason);
        this.ws = undefined;
    };
    SturdyWebSocket.prototype.clearAllTimeouts = function () {
        this.clearConnectTimeout();
        this.clearAllClearTimeout();
    };
    SturdyWebSocket.prototype.clearConnectTimeout = function () {
        if (this.connectTimeoutId != null) {
            clearTimeout(this.connectTimeoutId);
            this.connectTimeoutId = undefined;
        }
    };
    SturdyWebSocket.prototype.clearAllClearTimeout = function () {
        if (this.allClearTimeoutId != null) {
            clearTimeout(this.allClearTimeoutId);
            this.allClearTimeoutId = undefined;
        }
    };
    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {
        var _this = this;
        switch (type) {
            case "close":
                if (this.onclose) {
                    this.onclose(event);
                }
                break;
            case "error":
                if (this.onerror) {
                    this.onerror(event);
                }
                break;
            case "message":
                if (this.onmessage) {
                    this.onmessage(event);
                }
                break;
            case "open":
                if (this.onopen) {
                    this.onopen(event);
                }
                break;
            case "down":
                if (this.ondown) {
                    this.ondown(event);
                }
                break;
            case "reopen":
                if (this.onreopen) {
                    this.onreopen(event);
                }
                break;
        }
        if (type in this.listeners) {
            this.listeners[type]
                .slice()
                .forEach(function (listener) { return _this.callListener(listener, event); });
        }
        return !event || !event.defaultPrevented;
    };
    SturdyWebSocket.prototype.callListener = function (listener, event) {
        if (typeof listener === "function") {
            listener.call(this, event);
        }
        else {
            listener.handleEvent.call(this, event);
        }
    };
    SturdyWebSocket.prototype.debugLog = function (message) {
        if (this.options.debug) {
            // tslint:disable-next-line:no-console
            console.log(message);
        }
    };
    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {
        var maxReconnectAttempts = this.options.maxReconnectAttempts;
        return "Failed to reconnect after " + maxReconnectAttempts + " " + pluralize("attempt", maxReconnectAttempts) + ". Closing permanently.";
    };
    SturdyWebSocket.DEFAULT_OPTIONS = {
        allClearResetTime: 5000,
        connectTimeout: 5000,
        debug: false,
        minReconnectDelay: 1000,
        maxReconnectDelay: 30000,
        maxReconnectAttempts: Number.POSITIVE_INFINITY,
        reconnectBackoffFactor: 1.5,
        shouldReconnect: function () { return true; },
        wsConstructor: undefined,
    };
    SturdyWebSocket.CONNECTING = 0;
    SturdyWebSocket.OPEN = 1;
    SturdyWebSocket.CLOSING = 2;
    SturdyWebSocket.CLOSED = 3;
    return SturdyWebSocket;
}());
exports["default"] = SturdyWebSocket;
function applyDefaultOptions(options) {
    var result = {};
    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {
        var value = options[key];
        result[key] =
            value === undefined
                ? SturdyWebSocket.DEFAULT_OPTIONS[key]
                : value;
    });
    return result;
}
function getDataByteLength(data) {
    if (typeof data === "string") {
        // UTF-16 strings use two bytes per character.
        return 2 * data.length;
    }
    else if (data instanceof ArrayBuffer) {
        return data.byteLength;
    }
    else if (data instanceof Blob) {
        return data.size;
    }
    else {
        return undefined;
    }
}
function pluralize(s, n) {
    return n === 1 ? s : s + "s";
}
function noop() {
    // Nothing.
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/websocket/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/browser.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _globalThis;
if (typeof globalThis === 'object') {
	_globalThis = globalThis;
} else {
	try {
		_globalThis = __webpack_require__(/*! es5-ext/global */ "./node_modules/es5-ext/global.js");
	} catch (error) {
	} finally {
		if (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }
		if (!_globalThis) { throw new Error('Could not determine global this'); }
	}
}

var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
var websocket_version = __webpack_require__(/*! ./version */ "./node_modules/websocket/lib/version.js");


/**
 * Expose a W3C WebSocket class with just one or two arguments.
 */
function W3CWebSocket(uri, protocols) {
	var native_instance;

	if (protocols) {
		native_instance = new NativeWebSocket(uri, protocols);
	}
	else {
		native_instance = new NativeWebSocket(uri);
	}

	/**
	 * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
	 * class). Since it is an Object it will be returned as it is when creating an
	 * instance of W3CWebSocket via 'new W3CWebSocket()'.
	 *
	 * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
	 */
	return native_instance;
}
if (NativeWebSocket) {
	['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
		Object.defineProperty(W3CWebSocket, prop, {
			get: function() { return NativeWebSocket[prop]; }
		});
	});
}

/**
 * Module exports.
 */
module.exports = {
    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
    'version'      : websocket_version
};


/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ../package.json */ "./node_modules/websocket/package.json").version;


/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"_from":"websocket@^1.0.34","_id":"websocket@1.0.34","_inBundle":false,"_integrity":"sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==","_location":"/websocket","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"websocket@^1.0.34","name":"websocket","escapedName":"websocket","rawSpec":"^1.0.34","saveSpec":null,"fetchSpec":"^1.0.34"},"_requiredBy":["/alchemy-sdk"],"_resolved":"https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz","_shasum":"2bdc2602c08bf2c82253b730655c0ef7dcab3111","_spec":"websocket@^1.0.34","_where":"/Users/user/Documents/projects/blockmoney/node_modules/alchemy-sdk","author":{"name":"Brian McKelvey","email":"theturtle32@gmail.com","url":"https://github.com/theturtle32"},"browser":"lib/browser.js","bugs":{"url":"https://github.com/theturtle32/WebSocket-Node/issues"},"bundleDependencies":false,"config":{"verbose":false},"contributors":[{"name":"Iñaki Baz Castillo","email":"ibc@aliax.net","url":"http://dev.sipdoc.net"}],"dependencies":{"bufferutil":"^4.0.1","debug":"^2.2.0","es5-ext":"^0.10.50","typedarray-to-buffer":"^3.1.5","utf-8-validate":"^5.0.2","yaeti":"^0.0.6"},"deprecated":false,"description":"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.","devDependencies":{"buffer-equal":"^1.0.0","gulp":"^4.0.2","gulp-jshint":"^2.0.4","jshint":"^2.0.0","jshint-stylish":"^2.2.1","tape":"^4.9.1"},"directories":{"lib":"./lib"},"engines":{"node":">=4.0.0"},"homepage":"https://github.com/theturtle32/WebSocket-Node","keywords":["websocket","websockets","socket","networking","comet","push","RFC-6455","realtime","server","client"],"license":"Apache-2.0","main":"index","name":"websocket","repository":{"type":"git","url":"git+https://github.com/theturtle32/WebSocket-Node.git"},"scripts":{"gulp":"gulp","test":"tape test/unit/*.js"},"version":"1.0.34"}');

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYWxjaGVteS1zZGtfZGlzdF9lc21fYWxjaGVteS13ZWJzb2NrZXQtcHJvdmlkZXItNDhiYmIwZWRfanMuYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNxRDtBQUNNO0FBQ0w7QUFDckI7QUFDYztBQUNWO0FBQ3JDLG1CQUFtQix5REFBTSxDQUFDLDZDQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0MsK0RBQWU7QUFDdEQ7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxzRkFBc0Ysc0ZBQW1DO0FBQ3pIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5RUFBYyx5QkFBeUIsMENBQVM7QUFDNUQ7QUFDQTtBQUNBLFlBQVkseUVBQWM7QUFDMUI7QUFDQSxRQUFRLHlFQUFjLHNCQUFzQjtBQUM1QyxRQUFRLHlFQUFjLGtCQUFrQjtBQUN4QyxRQUFRLHlFQUFjLG9CQUFvQjtBQUMxQyxRQUFRLHlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUVBQWM7QUFDdEMs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQkFBMEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBCQUEwQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEZBQWlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscURBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLHFEQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1CQUFtQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGlCQUFpQiwyQkFBMkIsMENBQTBDO0FBQ3JJO0FBQ0E7O0FBRXdEO0FBQ3hEOzs7Ozs7Ozs7OztBQ2wwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNsQ1k7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHdCQUF3QjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsMENBQTBDO0FBQzFDLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FDblpBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdEQUFnQjtBQUN4QyxHQUFHO0FBQ0gsR0FBRztBQUNILHVEQUF1RDtBQUN2RCxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBEQUFXOzs7QUFHM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBLDRHQUFtRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Jsb2NrbW9uZXkvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd2Vic29ja2V0LXByb3ZpZGVyLmpzIiwid2VicGFjazovL2Jsb2NrbW9uZXkvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd3MuanMiLCJ3ZWJwYWNrOi8vYmxvY2ttb25leS8uL25vZGVfbW9kdWxlcy9hbGNoZW15LXNkay9kaXN0L2VzbS9hbGNoZW15LXdlYnNvY2tldC1wcm92aWRlci00OGJiYjBlZC5qcyIsIndlYnBhY2s6Ly9ibG9ja21vbmV5Ly4vbm9kZV9tb2R1bGVzL2VzNS1leHQvZ2xvYmFsLmpzIiwid2VicGFjazovL2Jsb2NrbW9uZXkvLi9ub2RlX21vZHVsZXMvc3R1cmR5LXdlYnNvY2tldC9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL2Jsb2NrbW9uZXkvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi9icm93c2VyLmpzIiwid2VicGFjazovL2Jsb2NrbW9uZXkvLi9ub2RlX21vZHVsZXMvd2Vic29ja2V0L2xpYi92ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9qc29uLXJwYy1wcm92aWRlclwiO1xuaW1wb3J0IHsgV2ViU29ja2V0IH0gZnJvbSBcIi4vd3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8qKlxuICogIE5vdGVzOlxuICpcbiAqICBUaGlzIHByb3ZpZGVyIGRpZmZlcnMgYSBiaXQgZnJvbSB0aGUgcG9sbGluZyBwcm92aWRlcnMuIE9uZSBtYWluXG4gKiAgZGlmZmVyZW5jZSBpcyBob3cgaXQgaGFuZGxlcyBjb25zaXN0ZW5jeS4gVGhlIHBvbGxpbmcgcHJvdmlkZXJzXG4gKiAgd2lsbCBzdGFsbCByZXNwb25zZXMgdG8gZW5zdXJlIGEgY29uc2lzdGVudCBzdGF0ZSwgd2hpbGUgdGhpc1xuICogIFdlYlNvY2tldCBwcm92aWRlciBhc3N1bWVzIHRoZSBjb25uZWN0ZWQgYmFja2VuZCB3aWxsIG1hbmFnZSB0aGlzLlxuICpcbiAqICBGb3IgZXhhbXBsZSwgaWYgYSBwb2xsaW5nIHByb3ZpZGVyIGVtaXRzIGFuIGV2ZW50IHdoaWNoIGluZGljYXRlc1xuICogIHRoZSBldmVudCBvY2N1cnJlZCBpbiBibG9ja2hhc2ggWFhYLCBhIGNhbGwgdG8gZmV0Y2ggdGhhdCBibG9jayBieVxuICogIGl0cyBoYXNoIFhYWCwgaWYgbm90IHByZXNlbnQgd2lsbCByZXRyeSB1bnRpbCBpdCBpcyBwcmVzZW50LiBUaGlzXG4gKiAgY2FuIG9jY3VyIHdoZW4gcXVlcnlpbmcgYSBwb29sIG9mIG5vZGVzIHRoYXQgYXJlIG1pbGRseSBvdXQgb2Ygc3luY1xuICogIHdpdGggZWFjaCBvdGhlci5cbiAqL1xubGV0IE5leHRJZCA9IDE7XG4vLyBGb3IgbW9yZSBpbmZvIGFib3V0IHRoZSBSZWFsLXRpbWUgRXZlbnQgQVBJIHNlZTpcbi8vICAgaHR0cHM6Ly9nZXRoLmV0aGVyZXVtLm9yZy9kb2NzL3JwYy9wdWJzdWJcbmV4cG9ydCBjbGFzcyBXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIEpzb25ScGNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSB0byBleHBlZGl0ZVxuICAgICAgICBpZiAobmV0d29yayA9PT0gXCJhbnlcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJXZWJTb2NrZXRQcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0ICdhbnknIG5ldHdvcmsgeWV0XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldHdvcms6YW55XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHN1cGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlcihcIl93ZWJzb2NrZXRcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gLTE7XG4gICAgICAgIHRoaXMuX3dzUmVhZHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd2Vic29ja2V0XCIsIG5ldyBXZWJTb2NrZXQodGhpcy5jb25uZWN0aW9uLnVybCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd2Vic29ja2V0XCIsIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcmVxdWVzdHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9zdWJzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfc3ViSWRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZGV0ZWN0TmV0d29ya1wiLCBzdXBlci5kZXRlY3ROZXR3b3JrKCkpO1xuICAgICAgICAvLyBTdGFsbCBzZW5kaW5nIHJlcXVlc3RzIHVudGlsIHRoZSBzb2NrZXQgaXMgb3Blbi4uLlxuICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl93c1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlcXVlc3RzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQodGhpcy5fcmVxdWVzdHNbaWRdLnBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud2Vic29ja2V0Lm9ubWVzc2FnZSA9IChtZXNzYWdlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtZXNzYWdlRXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IFN0cmluZyhyZXN1bHQuaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlcXVlc3RzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShyZXF1ZXN0LnBheWxvYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGVycm9yLCBcImNvZGVcIiwgcmVzdWx0LmVycm9yLmNvZGUgfHwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seShlcnJvciwgXCJyZXNwb25zZVwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9yLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5tZXRob2QgPT09IFwiZXRoX3N1YnNjcmlwdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uLi4uXG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5fc3Vic1tyZXN1bHQucGFyYW1zLnN1YnNjcmlwdGlvbl07XG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICAvL3RoaXMuZW1pdC5hcHBseSh0aGlzLCAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi5wcm9jZXNzRnVuYyhyZXN1bHQucGFyYW1zLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBQcm92aWRlciBkb2VzIG5vdCBhY3R1YWxseSBwb2xsLCBidXQgd2Ugd2FudCB0byB0cmlnZ2VyXG4gICAgICAgIC8vIHBvbGwgZXZlbnRzIGZvciB0aGluZ3MgdGhhdCBkZXBlbmQgb24gdGhlbSAobGlrZSBzdGFsbGluZyBmb3JcbiAgICAgICAgLy8gYmxvY2sgYW5kIHRyYW5zYWN0aW9uIGxvb2t1cHMpXG4gICAgICAgIGNvbnN0IGZhdXhQb2xsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIGlmIChmYXV4UG9sbC51bnJlZikge1xuICAgICAgICAgICAgZmF1eFBvbGwudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYW5ub3QgbmFycm93IHRoZSB0eXBlIG9mIF93ZWJzb2NrZXQsIGFzIHRoYXQgaXMgbm90IGJhY2t3YXJkcyBjb21wYXRpYmxlXG4gICAgLy8gc28gd2UgYWRkIGEgZ2V0dGVyIGFuZCBsZXQgdGhlIFdlYlNvY2tldCBiZSBhIHB1YmxpYyBBUEkuXG4gICAgZ2V0IHdlYnNvY2tldCgpIHsgcmV0dXJuIHRoaXMuX3dlYnNvY2tldDsgfVxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXRlY3ROZXR3b3JrO1xuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmVzZXRFdmVudHNCbG9jayhibG9ja051bWJlcikge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCByZXNldCBldmVudHMgYmxvY2sgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNldEV2ZW50QmxvY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmdJbnRlcnZhbCh2YWx1ZSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBpbnRlcnZhbCBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdJbnRlcnZhbFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRQb2xsaW5nXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmlkID0gTmV4dElkKys7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBpZDogcmlkLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogSlNPTi5wYXJzZShwYXlsb2FkKSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0c1tTdHJpbmcocmlkKV0gPSB7IGNhbGxiYWNrLCBwYXlsb2FkIH07XG4gICAgICAgICAgICBpZiAodGhpcy5fd3NSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwid3M6L1xcL2xvY2FsaG9zdDo4NTQ2XCI7XG4gICAgfVxuICAgIF9zdWJzY3JpYmUodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcmFtKS50aGVuKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX3N1YnNjcmliZVwiLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IHlpZWxkIHN1YklkUHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWcsIHByb2Nlc3NGdW5jIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcImJsb2NrXCIsIFtcIm5ld0hlYWRzXCJdLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gQmlnTnVtYmVyLmZyb20ocmVzdWx0Lm51bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInBlbmRpbmdcIiwgW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0UmVjZWlwdCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gZXZlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXQgaXMgYWxyZWFkeSBtaW5lZFxuICAgICAgICAgICAgICAgIGVtaXRSZWNlaXB0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgYW4gZXllIG91dCBmb3IgdHJhbnNhY3Rpb25zIHdlIGFyZSB3YXRjaGluZyBmb3IuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBzdWJzY3JpcHRpb24gZm9yIGFuIGV2ZW50IChpLmUuIFwidHhcIikgdGhhdCBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJ0eFwiLCBbXCJuZXdIZWFkc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiAoZS50eXBlID09PSBcInR4XCIpKS5mb3JFYWNoKGVtaXRSZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaWRQb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQ6XCIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCB0YWcgPSBldmVudC50YWc7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcInR4XCIpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gKGUudHlwZSA9PT0gXCJ0eFwiKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgaWYgKCFzdWJJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgc3ViSWQudGhlbigoc3ViSWQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic1tzdWJJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic1tzdWJJZF07XG4gICAgICAgICAgICB0aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB3ZSBoYXZlIGNvbm5lY3RlZCBiZWZvcmUgdHJ5aW5nIHRvIGRpc2Nvbm5lY3RcbiAgICAgICAgICAgIGlmICh0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgIHlpZWxkIChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZ3VwXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuY2xvc2UoMTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xubGV0IFdTID0gbnVsbDtcbnRyeSB7XG4gICAgV1MgPSBXZWJTb2NrZXQ7XG4gICAgaWYgKFdTID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5qZWN0IHBsZWFzZVwiKTtcbiAgICB9XG59XG5jYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgIFdTID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIldlYlNvY2tldHMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFdlYlNvY2tldCgpXCJcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbi8vZXhwb3J0IGRlZmF1bHQgV1M7XG4vL21vZHVsZS5leHBvcnRzID0gV1M7XG5leHBvcnQgeyBXUyBhcyBXZWJTb2NrZXQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdzLmpzLm1hcCIsImltcG9ydCB7IF8gYXMgX19hd2FpdGVyLCBmIGFzIGZyb21IZXgsIHQgYXMgdG9IZXgsIG4gYXMgbm9vcCwgQyBhcyBDdXN0b21OZXR3b3JrcywgRCBhcyBERUZBVUxUX0FMQ0hFTVlfQVBJX0tFWSwgViBhcyBWRVJTSU9OLCBFIGFzIEV0aGVyc05ldHdvcmsgfSBmcm9tICcuL2luZGV4LTZiY2E5MzBhLmpzJztcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ0BldGhlcnNwcm9qZWN0L2JpZ251bWJlcic7XG5pbXBvcnQgeyBBbGNoZW15UHJvdmlkZXIgfSBmcm9tICcuL2FsY2hlbXktcHJvdmlkZXItZmFhNWQ4YjEuanMnO1xuaW1wb3J0IFN0dXJkeVdlYlNvY2tldCBmcm9tICdzdHVyZHktd2Vic29ja2V0JztcbmltcG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSAnQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzJztcbmltcG9ydCB7IGdldE5ldHdvcmsgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9uZXR3b3Jrcyc7XG5pbXBvcnQgJy4vYXBpL3V0aWxzJztcbmltcG9ydCAnYXhpb3MnO1xuaW1wb3J0ICdAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlcic7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L3dhbGxldCc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cyc7XG5pbXBvcnQgJ0BldGhlcnNwcm9qZWN0L3dlYic7XG5cbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgYmxvY2tzIHRvIGJhY2tmaWxsLiBJZiBtb3JlIHRoYW4gdGhpcyBtYW55IGJsb2NrcyBoYXZlXHJcbiAqIGJlZW4gbWlzc2VkLCB0aGVuIHdlJ2xsIHNhZGx5IG1pc3MgZGF0YSwgYnV0IHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGRvbid0XHJcbiAqIGVuZCB1cCByZXF1ZXN0aW5nIHRob3VzYW5kcyBvZiBibG9ja3MgaWYgc29tZWJvZHkgbGVmdCB0aGVpciBsYXB0b3AgY2xvc2VkIGZvciBhIHdlZWsuXHJcbiAqL1xyXG5jb25zdCBNQVhfQkFDS0ZJTExfQkxPQ0tTID0gMTIwO1xyXG4vKipcclxuICogVGhlIFdlYnNvY2tldEJhY2tmaWxsZXIgZmV0Y2hlcyBldmVudHMgdGhhdCB3ZXJlIHNlbnQgc2luY2UgYSBwcm92aWRlZCBibG9ja1xyXG4gKiBudW1iZXIuIFRoaXMgaXMgdXNlZCBpbiB0aGUge0BsaW5rIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlcn0gdG8gYmFja2ZpbGxcclxuICogZXZlbnRzIHRoYXQgd2VyZSB0cmFuc21pdHRlZCB3aGlsZSB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRvd24uXHJcbiAqXHJcbiAqIFRoZSBiYWNrZmlsbGVyIGJhY2tmaWxscyB0d28gbWFpbiBldGhfc3Vic2NyaWJlIGV2ZW50czogYGxvZ3NgIGFuZCBgbmV3SGVhZHNgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFdlYnNvY2tldEJhY2tmaWxsZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgLy8gVE9ETzogVXNlIEhUVFAgcHJvdmlkZXIgdG8gZG8gYmFja2ZpbGwuXHJcbiAgICAgICAgdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyA9IE1BWF9CQUNLRklMTF9CTE9DS1M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgYmFja2ZpbGwgZm9yIGBuZXdIZWFkc2AgZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc0NhbmNlbGxlZCBXaGV0aGVyIHRoZSBiYWNrZmlsbCByZXF1ZXN0IGlzIGNhbmNlbGxlZC5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0hlYWRzIFByZXZpb3VzIGhlYWQgcmVxdWVzdHMgdGhhdCB3ZXJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gZnJvbUJsb2NrTnVtYmVyIFRoZSBibG9jayBudW1iZXIgdG8gc3RhcnQgYmFja2ZpbGxpbmcgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiBgbmV3SGVhZHNgIGV2ZW50cyB0aGF0IHdlcmUgc2VudCBzaW5jZSB0aGUgbGFzdCBiYWNrZmlsbC5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV3SGVhZHNCYWNrZmlsbChpc0NhbmNlbGxlZCwgcHJldmlvdXNIZWFkcywgZnJvbUJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvQmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLmdldEJsb2NrTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcHJldmlvdXMgaGVhZHMgdG8gZmV0Y2gsIHJldHVybiBuZXcgaGVhZHMgc2luY2VcclxuICAgICAgICAgICAgLy8gYGZyb21CbG9ja051bWJlcmAsIG9yIHVwIHRvIG1heEJhY2tmaWxsQmxvY2tzIGZyb20gdGhlIGN1cnJlbnQgaGVhZC5cclxuICAgICAgICAgICAgaWYgKHByZXZpb3VzSGVhZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRIZWFkRXZlbnRzSW5SYW5nZShNYXRoLm1heChmcm9tQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzKSArIDEsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBlbWl0dGVkIGV2ZW50IGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW9yZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYCB3b3J0aCBvZlxyXG4gICAgICAgICAgICAvLyBuZXcgaGVhZHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTZWVuQmxvY2tOdW1iZXIgPSBmcm9tSGV4KHByZXZpb3VzSGVhZHNbcHJldmlvdXNIZWFkcy5sZW5ndGggLSAxXS5udW1iZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBtaW5CbG9ja051bWJlciA9IHRvQmxvY2tOdW1iZXIgLSB0aGlzLm1heEJhY2tmaWxsQmxvY2tzICsgMTtcclxuICAgICAgICAgICAgaWYgKGxhc3RTZWVuQmxvY2tOdW1iZXIgPD0gbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKG1pbkJsb2NrTnVtYmVyLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVG8gY2FwdHVyZSBhbGwgYG5ld0hlYWRzYCBldmVudHMsIHJldHVybiBhbGwgaGVhZCBldmVudHMgZnJvbSB0aGUgbGFzdFxyXG4gICAgICAgICAgICAvLyBzZWVuIGJsb2NrIG51bWJlciB0byBjdXJyZW50ICsgYW55IG9mIHRoZSBwcmV2aW91cyBoZWFkcyB0aGF0IHdlcmUgcmUtb3JnZWQuXHJcbiAgICAgICAgICAgIGNvbnN0IHJlb3JnSGVhZHMgPSB5aWVsZCB0aGlzLmdldFJlb3JnSGVhZHMoaXNDYW5jZWxsZWQsIHByZXZpb3VzSGVhZHMpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSGVhZHMgPSB5aWVsZCB0aGlzLmdldEhlYWRFdmVudHNJblJhbmdlKGxhc3RTZWVuQmxvY2tOdW1iZXIgKyAxLCB0b0Jsb2NrTnVtYmVyICsgMSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlb3JnSGVhZHMsIC4uLmludGVybWVkaWF0ZUhlYWRzXTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUnVucyBiYWNrZmlsbCBmb3IgYGxvZ3NgIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXNDYW5jZWxsZWQgV2hldGhlciB0aGUgYmFja2ZpbGwgcmVxdWVzdCBpcyBjYW5jZWxsZWQuXHJcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSBmaWx0ZXIgb2JqZWN0IHRoYXQgYWNjb21wYW5pZXMgYSBsb2dzIHN1YnNjcmlwdGlvbi5cclxuICAgICAqIEBwYXJhbSBwcmV2aW91c0xvZ3MgUHJldmlvdXMgbG9nIHJlcXVlc3RzIHRoYXQgd2VyZSBzZW50LlxyXG4gICAgICogQHBhcmFtIGZyb21CbG9ja051bWJlciBUaGUgYmxvY2sgbnVtYmVyIHRvIHN0YXJ0IGJhY2tmaWxsaW5nIGZyb20uXHJcbiAgICAgKi9cclxuICAgIGdldExvZ3NCYWNrZmlsbChpc0NhbmNlbGxlZCwgZmlsdGVyLCBwcmV2aW91c0xvZ3MsIGZyb21CbG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCB0b0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHByZXZpb3VzIGxvZ3MgdG8gZmV0Y2gsIHJldHVybiBuZXcgbG9ncyBzaW5jZVxyXG4gICAgICAgICAgICAvLyBgZnJvbUJsb2NrTnVtYmVyYCwgb3IgdXAgdG8gYG1heEJhY2tmaWxsQmxvY2tzYCBmcm9tIHRoZSBjdXJyZW50IGhlYWQuXHJcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0xvZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMb2dzSW5SYW5nZShmaWx0ZXIsIE1hdGgubWF4KGZyb21CbG9ja051bWJlciwgdG9CbG9ja051bWJlciAtIHRoaXMubWF4QmFja2ZpbGxCbG9ja3MpICsgMSwgdG9CbG9ja051bWJlciArIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBsYXN0IGVtaXR0ZWQgbG9nIGlzIHRvbyBmYXIgYmFjayBpbiB0aGUgcGFzdCwgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgICAgICAgIC8vIHRvIGJhY2tmaWxsIGZvciByZW1vdmVkIGxvZ3MuIEp1c3QgZmV0Y2ggdGhlIGxhc3QgYG1heEJhY2tmaWxsQmxvY2tzYFxyXG4gICAgICAgICAgICAvLyB3b3J0aCBvZiBsb2dzLlxyXG4gICAgICAgICAgICBjb25zdCBsYXN0U2VlbkJsb2NrTnVtYmVyID0gZnJvbUhleChwcmV2aW91c0xvZ3NbcHJldmlvdXNMb2dzLmxlbmd0aCAtIDFdLmJsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgY29uc3QgbWluQmxvY2tOdW1iZXIgPSB0b0Jsb2NrTnVtYmVyIC0gdGhpcy5tYXhCYWNrZmlsbEJsb2NrcyArIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0U2VlbkJsb2NrTnVtYmVyIDwgbWluQmxvY2tOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExvZ3NJblJhbmdlKGZpbHRlciwgbWluQmxvY2tOdW1iZXIsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxsIGxvZyBldmVudHMgdGhhdCBoYXZlIGhhcHBlbmVkIGFsb25nIHdpdGggbG9nIGV2ZW50cyB0aGF0IGhhdmVcclxuICAgICAgICAgICAgLy8gYmVlbiByZW1vdmVkIGR1ZSB0byBhIGNoYWluIHJlb3JnLlxyXG4gICAgICAgICAgICBjb25zdCBjb21tb25BbmNlc3RvciA9IHlpZWxkIHRoaXMuZ2V0Q29tbW9uQW5jZXN0b3IoaXNDYW5jZWxsZWQsIHByZXZpb3VzTG9ncyk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAvLyBBbGwgcHJldmlvdXMgbG9ncyB3aXRoIGEgYmxvY2sgbnVtYmVyIGdyZWF0ZXIgdGhhbiB0aGUgY29tbW9uIGFuY2VzdG9yXHJcbiAgICAgICAgICAgIC8vIHdlcmUgcGFydCBvZiBhIHJlLW9yZywgc28gbWFyayB0aGVtIGFzIHN1Y2guXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRMb2dzID0gcHJldmlvdXNMb2dzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGxvZyA9PiBmcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcilcclxuICAgICAgICAgICAgICAgIC5tYXAobG9nID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZyksIHsgcmVtb3ZlZDogdHJ1ZSB9KSkpO1xyXG4gICAgICAgICAgICAvLyBJZiBubyBjb21tb24gYW5jZXN0b3Igd2FzIGZvdW5kLCBzdGFydCBiYWNrZmlsbCBmcm9tIHRoZSBvbGRlc3QgbG9nJ3NcclxuICAgICAgICAgICAgLy8gYmxvY2sgbnVtYmVyLlxyXG4gICAgICAgICAgICBjb25zdCBmcm9tQmxvY2tJbmNsdXNpdmUgPSBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXHJcbiAgICAgICAgICAgICAgICA/IGZyb21IZXgocHJldmlvdXNMb2dzWzBdLmJsb2NrTnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgOiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlcjtcclxuICAgICAgICAgICAgbGV0IGFkZGVkTG9ncyA9IHlpZWxkIHRoaXMuZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tOdW1iZXIgKyAxKTtcclxuICAgICAgICAgICAgLy8gRGUtZHVwZSBhbnkgbG9ncyB0aGF0IHdlcmUgYWxyZWFkeSBlbWl0dGVkLlxyXG4gICAgICAgICAgICBhZGRlZExvZ3MgPSBhZGRlZExvZ3MuZmlsdGVyKGxvZyA9PiBsb2cgJiZcclxuICAgICAgICAgICAgICAgIChmcm9tSGV4KGxvZy5ibG9ja051bWJlcikgPiBjb21tb25BbmNlc3Rvci5ibG9ja051bWJlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21IZXgobG9nLmxvZ0luZGV4KSA+IGNvbW1vbkFuY2VzdG9yLmxvZ0luZGV4KSk7XHJcbiAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlbW92ZWRMb2dzLCAuLi5hZGRlZExvZ3NdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgbmV3IG1heCBiYWNrZmlsbCBibG9ja3MuIFZJU0lCTEUgT05MWSBGT1IgVEVTVElORy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc2V0TWF4QmFja2ZpbGxCbG9jayhuZXdNYXgpIHtcclxuICAgICAgICB0aGlzLm1heEJhY2tmaWxsQmxvY2tzID0gbmV3TWF4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGJsb2NrIG51bWJlciBhcyBhIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRCbG9ja051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlckhleCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2Jsb2NrTnVtYmVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KGJsb2NrTnVtYmVySGV4KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYG5ld0hlYWRgIGV2ZW50cyBpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWRcclxuICAgICAqIGhlYWRzIGRvIG5vdCBpbmNsdWRlIHJlLW9yZ2VkIGhlYWRzLiBVc2Uge0BsaW5rIGdldFJlb3JnSGVhZHN9IHRvIGZpbmQgaGVhZHNcclxuICAgICAqIHRoYXQgd2VyZSBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldEhlYWRFdmVudHNJblJhbmdlKGZyb21CbG9ja0luY2x1c2l2ZSwgdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChmcm9tQmxvY2tJbmNsdXNpdmUgPj0gdG9CbG9ja0V4Y2x1c2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZyb21CbG9ja0luY2x1c2l2ZTsgaSA8IHRvQmxvY2tFeGNsdXNpdmU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2hQYXJ0cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbdG9IZXgoaSksIGZhbHNlXVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzoganVzdCBmaXJlIG9mZiBlYWNoIHNlbmQoKSBzZXBhcmF0ZWx5IHNpbmNlIHdlJ3JlIG5vIGxvbmdlciBiYXRjaGluZzpcclxuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVycm9yc1xyXG4gICAgICAgICAgICBjb25zdCBiYXRjaGVkQmxvY2tIZWFkcyA9IHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZEJhdGNoKGJhdGNoUGFydHMpO1xyXG4gICAgICAgICAgICBjb25zdCBibG9ja0hlYWRzID0gYmF0Y2hlZEJsb2NrSGVhZHMucmVkdWNlKChhY2MsIGJhdGNoKSA9PiBhY2MuY29uY2F0KGJhdGNoKSwgW10pO1xyXG4gICAgICAgICAgICByZXR1cm4gYmxvY2tIZWFkcy5tYXAodG9OZXdIZWFkc0V2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgaGVhZHMgdGhhdCB3ZXJlIHBhcnQgb2YgYSByZW9yZyBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRSZW9yZ0hlYWRzKGlzQ2FuY2VsbGVkLCBwcmV2aW91c0hlYWRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgZnJvbSB0aGUgbW9zdCByZWNlbnQgaGVhZCBiYWNrd2FyZHMgaW4gb3JkZXIgdG8gZmluZCB0aGUgZmlyc3RcclxuICAgICAgICAgICAgLy8gYmxvY2sgdGhhdCB3YXMgcGFydCBvZiBhIHJlLW9yZy5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzSGVhZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZEV2ZW50ID0gcHJldmlvdXNIZWFkc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrSGVhZCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tCeU51bWJlcihmcm9tSGV4KG9sZEV2ZW50Lm51bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaGFzaGVzIG1hdGNoLCB0aGVuIGN1cnJlbnQgaGVhZCBpbiB0aGUgaXRlcmF0aW9uIHdhcyBub3QgcmUtb3JnZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkRXZlbnQuaGFzaCA9PT0gYmxvY2tIZWFkLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvTmV3SGVhZHNFdmVudChibG9ja0hlYWQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIHdyYXBwZXIgYXJvdW5kIGBldGhfZ2V0QmxvY2tCeU51bWJlcmAgdGhhdCByZXR1cm5zIHRoZSBjb21wbGV0ZVxyXG4gICAgICogYmxvY2sgaW5mb3JtYXRpb24gZm9yIHRoZSBwcm92aWRlZCBibG9jayBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlcikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJywgW1xyXG4gICAgICAgICAgICAgICAgdG9IZXgoYmxvY2tOdW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgZmFsc2VcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBwcmV2aW91cyBsb2cgZXZlbnRzLCBmaW5kcyB0aGUgY29tbW9uIGJsb2NrIG51bWJlciBmcm9tIHRoZVxyXG4gICAgICogbG9ncyB0aGF0IG1hdGNoZXMgdGhlIGJsb2NrIGhlYWQuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB3aGljaCBsb2dzIGFyZSBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICpcclxuICAgICAqIFJldHVybnMgMSBsZXNzIHRoYW4gdGhlIG9sZGVzdCBsb2cncyBibG9jayBudW1iZXIgaWYgbm8gY29tbW9uIGFuY2VzdG9yIHdhcyBmb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRDb21tb25BbmNlc3Rvcihpc0NhbmNlbGxlZCwgcHJldmlvdXNMb2dzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSBmcm9tIHRoZSBtb3N0IHJlY2VudCBoZWFkIGJhY2t3YXJkcyBpbiBvcmRlciB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAvLyBibG9jayB0aGF0IHdhcyBwYXJ0IG9mIGEgcmUtb3JnLlxyXG4gICAgICAgICAgICBsZXQgYmxvY2tIZWFkID0geWllbGQgdGhpcy5nZXRCbG9ja0J5TnVtYmVyKGZyb21IZXgocHJldmlvdXNMb2dzW3ByZXZpb3VzTG9ncy5sZW5ndGggLSAxXS5ibG9ja051bWJlcikpO1xyXG4gICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByZXZpb3VzTG9ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkTG9nID0gcHJldmlvdXNMb2dzW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgdXBkYXRlZCBibG9ja3MgYXJlIGZldGNoZWQgZXZlcnkgdGltZSB0aGUgbG9nJ3MgYmxvY2sgbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9sZExvZy5ibG9ja051bWJlciAhPT0gYmxvY2tIZWFkLm51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSGVhZCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tCeU51bWJlcihmcm9tSGV4KG9sZExvZy5ibG9ja051bWJlcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgbG9ncyBhcmUgb3JkZXJlZCBpbiBhc2NlbmRpbmcgb3JkZXIsIHRoZSBmaXJzdCBsb2cgdGhhdCBtYXRjaGVzXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgaGFzaCBzaG91bGQgYmUgdGhlIGxhcmdlc3QgbG9nSW5kZXguXHJcbiAgICAgICAgICAgICAgICBpZiAob2xkTG9nLmJsb2NrSGFzaCA9PT0gYmxvY2tIZWFkLmhhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogZnJvbUhleChvbGRMb2cuYmxvY2tOdW1iZXIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dJbmRleDogZnJvbUhleChvbGRMb2cubG9nSW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcclxuICAgICAgICAgICAgICAgIGxvZ0luZGV4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgYGxvZ3NgIGV2ZW50cyBpbiB0aGUgcHJvdmlkZWQgcmFuZ2UuIE5vdGUgdGhhdCB0aGUgcmV0dXJuZWQgbG9nc1xyXG4gICAgICogZG8gbm90IGluY2x1ZGUgcmVtb3ZlZCBsb2dzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi8gZ2V0TG9nc0luUmFuZ2UoZmlsdGVyLCBmcm9tQmxvY2tJbmNsdXNpdmUsIHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrSW5jbHVzaXZlID49IHRvQmxvY2tFeGNsdXNpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByYW5nZUZpbHRlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsdGVyKSwgeyBmcm9tQmxvY2s6IHRvSGV4KGZyb21CbG9ja0luY2x1c2l2ZSksIHRvQmxvY2s6IHRvSGV4KHRvQmxvY2tFeGNsdXNpdmUgLSAxKSB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZCgnZXRoX2dldExvZ3MnLCBbcmFuZ2VGaWx0ZXJdKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0b05ld0hlYWRzRXZlbnQoaGVhZCkge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgaGVhZCk7XHJcbiAgICBkZWxldGUgcmVzdWx0LnRvdGFsRGlmZmljdWx0eTtcclxuICAgIGRlbGV0ZSByZXN1bHQudHJhbnNhY3Rpb25zO1xyXG4gICAgZGVsZXRlIHJlc3VsdC51bmNsZXM7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZU5ld0hlYWRzKGV2ZW50cykge1xyXG4gICAgcmV0dXJuIGRlZHVwZShldmVudHMsIGV2ZW50ID0+IGV2ZW50Lmhhc2gpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZUxvZ3MoZXZlbnRzKSB7XHJcbiAgICByZXR1cm4gZGVkdXBlKGV2ZW50cywgZXZlbnQgPT4gYCR7ZXZlbnQuYmxvY2tIYXNofS8ke2V2ZW50LmxvZ0luZGV4fWApO1xyXG59XHJcbmZ1bmN0aW9uIGRlZHVwZShpdGVtcywgZ2V0S2V5KSB7XHJcbiAgICBjb25zdCBrZXlzU2VlbiA9IG5ldyBTZXQoKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICBjb25zdCBrZXkgPSBnZXRLZXkoaXRlbSk7XHJcbiAgICAgICAgaWYgKCFrZXlzU2Vlbi5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICBrZXlzU2Vlbi5hZGQoa2V5KTtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmNvbnN0IENBTkNFTExFRCA9IG5ldyBFcnJvcignQ2FuY2VsbGVkJyk7XHJcbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpIHtcclxuICAgIGlmIChpc0NhbmNlbGxlZCgpKSB7XHJcbiAgICAgICAgdGhyb3cgQ0FOQ0VMTEVEO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBQcmVmaXggZm9yIGBhbGNoZW15X3BlbmRpbmdUcmFuc2FjdGlvbnNgIHN1YnNjcmlwdGlvbnMgd2hlbiBzZXJpYWxpemluZyB0b1xyXG4gKiBldGhlcnMgZXZlbnRzLlxyXG4gKi9cclxuY29uc3QgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFID0gJ2FsY2hlbXktcGVuZGluZy10cmFuc2FjdGlvbnMnO1xyXG4vKiogTWV0aG9kIG5hbWUgZm9yIEFsY2hlbXkgcGVuZGluZyB0cmFuc2FjdGlvbiBzdWJzY3JpcHRpb25zIHdoZW4gdXNpbmcgV2Vic29ja2V0cy4gKi9cclxuY29uc3QgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9NRVRIT0QgPSAnYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25zJztcclxuLyoqXHJcbiAqIERPIE5PVCBNT0RJRlkuXHJcbiAqXHJcbiAqIEV2ZW50IGNsYXNzIGNvcGllZCBkaXJlY3RseSBvdmVyIGZyb20gZXRoZXJzLmpzJ3MgYEJhc2VQcm92aWRlcmAgY2xhc3MuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byByZXByZXNlbnQgZXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIGxpc3RlbmVycy4gVGhlXHJcbiAqIFNESyBuZWVkcyB0byBleHRlbmQgdGhpcyBjbGFzcyBpbiBvcmRlciB0byBzdXBwb3J0IEFsY2hlbXkncyBjdXN0b21cclxuICogU3Vic2NyaXB0aW9uIEFQSSB0eXBlcy4gVGhlIG9yaWdpbmFsIGNsYXNzIGlzIG5vdCBleHBvcnRlZCBieSBldGhlcnMuIE1pbmltYWxcclxuICogY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSBpbiBvcmRlciB0byBnZXQgVFMgdG8gY29tcGlsZS5cclxuICovXHJcbmNsYXNzIEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhZywgbGlzdGVuZXIsIG9uY2UpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XHJcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XHJcbiAgICAgICAgdGhpcy5vbmNlID0gb25jZTtcclxuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcclxuICAgICAgICB0aGlzLl9pbmZsaWdodCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGV2ZW50KCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3R4JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc2g7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ZpbHRlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YWc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KCc6JylbMF07XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzaCgpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSAndHgnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdHJhbnNhY3Rpb24gZXZlbnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBzWzFdO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZpbHRlcigpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSAnZmlsdGVyJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHRyYW5zYWN0aW9uIGV2ZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wc1sxXTtcclxuICAgICAgICBjb25zdCB0b3BpY3MgPSBkZXNlcmlhbGl6ZVRvcGljcyhjb21wc1syXSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge307XHJcbiAgICAgICAgaWYgKHRvcGljcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGZpbHRlci50b3BpY3MgPSB0b3BpY3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09ICcqJykge1xyXG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaWx0ZXI7XHJcbiAgICB9XHJcbiAgICBwb2xsYWJsZSgpIHtcclxuICAgICAgICBjb25zdCBQb2xsYWJsZUV2ZW50cyA9IFsnYmxvY2snLCAnbmV0d29yaycsICdwZW5kaW5nJywgJ3BvbGwnXTtcclxuICAgICAgICByZXR1cm4gdGhpcy50YWcuaW5kZXhPZignOicpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogV3JhcHBlciBjbGFzcyBhcm91bmQgdGhlIGV0aGVycyBgRXZlbnRgIGNsYXNzIGluIG9yZGVyIHRvIGFkZCBzdXBwb3J0IGZvclxyXG4gKiBBbGNoZW15J3MgY3VzdG9tIHN1YnNjcmlwdGlvbnMgdHlwZXMuXHJcbiAqXHJcbiAqIFRoZSBnZXR0ZXJzIG9uIHRoaXMgY2xhc3MgZGVzZXJpYWxpemUgdGhlIGV2ZW50IHRhZyBnZW5lcmF0ZWQgYnlcclxuICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW50byB0aGUgb3JpZ2luYWwgZmllbGRzIHBhc3NlZCBpbnRvIHRoZSBldmVudC5cclxuICovXHJcbmNsYXNzIEV0aGVyc0V2ZW50IGV4dGVuZHMgRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZXZlbnQgdGFnIGludG8gdGhlIG9yaWdpbmFsIGBmcm9tQWRkcmVzc2AgZmllbGQgaW5cclxuICAgICAqIHtAbGluayBBbGNoZW15UGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGZyb21BZGRyZXNzKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoJzonKTtcclxuICAgICAgICBpZiAoY29tcHNbMF0gIT09IEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29tcHNbMV0gJiYgY29tcHNbMV0gIT09ICcqJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVBZGRyZXNzRmllbGQoY29tcHNbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHRoZSBldmVudCB0YWcgaW50byB0aGUgb3JpZ2luYWwgYHRvQWRkcmVzc2AgZmllbGQgaW5cclxuICAgICAqIHtAbGluayBBbGNoZW15UGVuZGluZ1RyYW5zYWN0aW9uc0V2ZW50RmlsdGVyfS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHRvQWRkcmVzcygpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBzWzJdICYmIGNvbXBzWzJdICE9PSAnKicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGNvbXBzWzJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyB0aGUgZXZlbnQgdGFnIGludG8gdGhlIG9yaWdpbmFsIGBoYXNoZXNPbmx5YCBmaWVsZCBpblxyXG4gICAgICoge0BsaW5rIEFsY2hlbXlQZW5kaW5nVHJhbnNhY3Rpb25zRXZlbnRGaWx0ZXJ9LlxyXG4gICAgICovXHJcbiAgICBnZXQgaGFzaGVzT25seSgpIHtcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBzWzNdICYmIGNvbXBzWzNdICE9PSAnKicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBzWzNdID09PSAndHJ1ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvcGljcyhkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAodG9waWMgPT4ge1xyXG4gICAgICAgIGlmICh0b3BpYyA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21wcyA9IHRvcGljLnNwbGl0KCd8JykubWFwKHRvcGljID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRvcGljID09PSAnbnVsbCcgPyBudWxsIDogdG9waWM7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBzLmxlbmd0aCA9PT0gMSA/IGNvbXBzWzBdIDogY29tcHM7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUFkZHJlc3NGaWVsZChkYXRhKSB7XHJcbiAgICBpZiAoZGF0YSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYWRkcmVzc2VzID0gZGF0YS5zcGxpdCgnfCcpO1xyXG4gICAgcmV0dXJuIGFkZHJlc3Nlcy5sZW5ndGggPT09IDEgPyBhZGRyZXNzZXNbMF0gOiBhZGRyZXNzZXM7XHJcbn1cblxuY29uc3QgSEVBUlRCRUFUX0lOVEVSVkFMID0gMzAwMDA7XHJcbmNvbnN0IEhFQVJUQkVBVF9XQUlUX1RJTUUgPSAxMDAwMDtcclxuY29uc3QgQkFDS0ZJTExfVElNRU9VVCA9IDYwMDAwO1xyXG5jb25zdCBCQUNLRklMTF9SRVRSSUVTID0gNTtcclxuLyoqXHJcbiAqIFN1YnNjcmlwdGlvbnMgaGF2ZSBhIG1lbW9yeSBvZiByZWNlbnQgZXZlbnRzIHRoZXkgaGF2ZSBzZW50IHNvIHRoYXQgaW4gdGhlXHJcbiAqIGV2ZW50IHRoYXQgdGhleSBkaXNjb25uZWN0IGFuZCBuZWVkIHRvIGJhY2tmaWxsLCB0aGV5IGNhbiBkZXRlY3QgcmUtb3Jncy5cclxuICogS2VlcCBhIGJ1ZmZlciB0aGF0IGdvZXMgYmFjayBhdCBsZWFzdCB0aGVzZSBtYW55IGJsb2NrcywgdGhlIG1heGltdW0gYW1vdW50XHJcbiAqIGF0IHdoaWNoIHdlIG1pZ2h0IGNvbmNlaXZhYmx5IHNlZSBhIHJlLW9yZy5cclxuICpcclxuICogTm90ZSB0aGF0IHdoaWxlIG91ciBidWZmZXIgZ29lcyBiYWNrIHRoaXMgbWFueSBibG9ja3MsIGl0IG1heSBjb250YWluIG1vcmVcclxuICogdGhhbiB0aGlzIG1hbnkgZWxlbWVudHMsIHNpbmNlIGluIHRoZSBjYXNlIG9mIGxvZ3Mgc3Vic2NyaXB0aW9ucyBtb3JlIHRoYW5cclxuICogb25lIGV2ZW50IG1heSBiZSBlbWl0dGVkIGZvciBhIGJsb2NrLlxyXG4gKi9cclxuY29uc3QgUkVUQUlORURfRVZFTlRfQkxPQ0tfQ09VTlQgPSAxMDtcclxuLyoqXHJcbiAqIFNESydzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiBmbyB0aGUgZXRoZXJzLmpzJ3MgJ0FsY2hlbXlXZWJTb2NrZXRQcm92aWRlcicuXHJcbiAqXHJcbiAqIERvIG5vdCBjYWxsIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuIEluc3RlYWQsIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mXHJcbiAqIHtAbGluayBBbGNoZW15fSBhbmQgY2FsbCB7QGxpbmsgQWxjaGVteS5jb25maWcuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKX0uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNsYXNzIEFsY2hlbXlXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIFdlYlNvY2tldFByb3ZpZGVyIHtcclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgd3NDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFQSSBLZXkgdG8gYSBzdHJpbmcuXHJcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gQWxjaGVteVByb3ZpZGVyLmdldEFwaUtleShjb25maWcuYXBpS2V5KTtcclxuICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgb3duIGNvbm5lY3Rpb24gaW5mbyB3aXRoIHRoZSBjb3JyZWN0IGVuZHBvaW50IFVSTHMuXHJcbiAgICAgICAgY29uc3QgYWxjaGVteU5ldHdvcmsgPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteU5ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xyXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBBbGNoZW15UHJvdmlkZXIuZ2V0QWxjaGVteUNvbm5lY3Rpb25JbmZvKGFsY2hlbXlOZXR3b3JrLCBhcGlLZXksICd3c3MnKTtcclxuICAgICAgICBjb25zdCBwcm90b2NvbCA9IGBhbGNoZW15LXNkay0ke1ZFUlNJT059YDtcclxuICAgICAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIGNvbmZpZyBVUkwgb3ZlcnJpZGUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgdXNlIHRoZSBjcmVhdGVkIG9uZS5cclxuICAgICAgICBjb25zdCB3cyA9IG5ldyBTdHVyZHlXZWJTb2NrZXQoKF9hID0gY29uZmlnLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29ubmVjdGlvbi51cmwsIHByb3RvY29sLCB7XHJcbiAgICAgICAgICAgIHdzQ29uc3RydWN0b3I6IHdzQ29uc3RydWN0b3IgIT09IG51bGwgJiYgd3NDb25zdHJ1Y3RvciAhPT0gdm9pZCAwID8gd3NDb25zdHJ1Y3RvciA6IGdldFdlYnNvY2tldENvbnN0cnVjdG9yKClcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIEFsY2hlbXkgbmFtZWQgbmV0d29yayBpbnB1dCB0byB0aGUgbmV0d29yayBuYW1lcyB1c2VkIGJ5XHJcbiAgICAgICAgLy8gZXRoZXJzLiBUaGlzIGFsbG93cyB0aGUgcGFyZW50IHN1cGVyIGNvbnN0cnVjdG9yIGluIEpzb25ScGNQcm92aWRlciB0b1xyXG4gICAgICAgIC8vIGNvcnJlY3RseSBzZXQgdGhlIG5ldHdvcmsuXHJcbiAgICAgICAgY29uc3QgZXRoZXJzTmV0d29yayA9IEV0aGVyc05ldHdvcmtbYWxjaGVteU5ldHdvcmtdO1xyXG4gICAgICAgIHN1cGVyKHdzLCBldGhlcnNOZXR3b3JrKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcclxuICAgICAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIFdlYlNvY2tldCByZWNvbm5lY3Rpb24sIGFsbCBzdWJzY3JpcHRpb25zIGFyZSBsb3N0IGFuZCB3ZVxyXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb25lcyB0byByZXBsYWNlIHRoZW0sIGJ1dCB3ZSB3YW50IHRvIGNyZWF0ZSB0aGUgaWxsdXNpb24gdGhhdFxyXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBzdWJzY3JpcHRpb25zIHBlcnNpc3QuIFRodXMsIG1haW50YWluIGEgbWFwcGluZyBmcm9tIHRoZVxyXG4gICAgICAgIC8vIFwidmlydHVhbFwiIHN1YnNjcmlwdGlvbiBpZHMgd2hpY2ggYXJlIHZpc2libGUgdG8gdGhlIGNvbnN1bWVyIHRvIHRoZVxyXG4gICAgICAgIC8vIFwicGh5c2ljYWxcIiBzdWJzY3JpcHRpb24gaWRzIG9mIHRoZSBhY3R1YWwgY29ubmVjdGlvbnMuIFRoaXMgdGVybWlub2xvZ3kgaXNcclxuICAgICAgICAvLyBib3Jyb3dlZCBmcm9tIHZpcnR1YWwgYW5kIHBoeXNpY2FsIG1lbW9yeSwgd2hpY2ggaGFzIGEgc2ltaWxhciBtYXBwaW5nLlxyXG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgICAgICB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvKiogQGludGVybmFsICovXHJcbiAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGV0aGVycyB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9IGFscmVhZHkgaGFuZGxlcyBhbmQgZW1pdHNcclxuICAgICAgICAgKiBtZXNzYWdlcy4gVG8gYWxsb3cgYmFja2ZpbGxpbmcsIHRyYWNrIGFsbCBtZXNzYWdlcyB0aGF0IGFyZSBlbWl0dGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBpcyBhIGZpZWxkIGFycm93IGZ1bmN0aW9uIGluIG9yZGVyIHRvIHByZXNlcnZlIGB0aGlzYCBjb250ZXh0IHdoZW5cclxuICAgICAgICAgKiBwYXNzaW5nIHRoZSBtZXRob2QgYXMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAaW50ZXJuYWxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICghaXNTdWJzY3JpcHRpb25FdmVudChtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBoeXNpY2FsSWQgPSBtZXNzYWdlLnBhcmFtcy5zdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHZpcnR1YWxJZCA9IHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5nZXQocGh5c2ljYWxJZCk7XHJcbiAgICAgICAgICAgIGlmICghdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24ubWV0aG9kICE9PSAnZXRoX3N1YnNjcmliZScpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnNjcmlwdGlvbi5wYXJhbXNbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld0hlYWRzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRzU3Vic2NyaXB0aW9uID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRzTWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc0JhY2tmaWxsaW5nLCBiYWNrZmlsbEJ1ZmZlciB9ID0gbmV3SGVhZHNTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IG5ld0hlYWRzTWVzc2FnZS5wYXJhbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmFja2ZpbGxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9OZXdIZWFkc0V2ZW50c0J1ZmZlcihiYWNrZmlsbEJ1ZmZlciwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGh5c2ljYWxJZCAhPT0gdmlydHVhbElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgcmUtb3BlbmVkIHN1YnNjcmlwdGlvbiwgZXRoZXJzIHdpbGwgbm90IGVtaXQgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50LCBzbyB0aGUgU0RLIGhhcyB0by5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0QW5kUmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0TmV3SGVhZHNCbG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFdGhlcnMgc3Vic2NyaXB0aW9uIG1hcHBpbmcgd2lsbCBlbWl0IHRoZSBldmVudCwganVzdCBzdG9yZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb2dzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ3NTdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9nc01lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNCYWNrZmlsbGluZywgYmFja2ZpbGxCdWZmZXIgfSA9IGxvZ3NTdWJzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IGxvZ3NNZXNzYWdlLnBhcmFtcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCYWNrZmlsbGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0xvZ3NFdmVudHNCdWZmZXIoYmFja2ZpbGxCdWZmZXIsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZpcnR1YWxJZCAhPT0gcGh5c2ljYWxJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gcmVvcGVuczpcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIDEuIFJlc3Vic2NyaWJlIHRvIGFsbCBleGlzdGluZyBzdWJzY3JpcHRpb25zIGFuZCBzdGFydCBiYWNrZmlsbGluZ1xyXG4gICAgICAgICAqIDIuIFJlc3RhcnQgaGVhcnQgYmVhdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oYW5kbGVSZW9wZW4gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmlydHVhbElkc0J5UGh5c2ljYWxJZC5jbGVhcigpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGNhbmNlbCwgaXNDYW5jZWxsZWQgfSA9IG1ha2VDYW5jZWxUb2tlbigpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEJhY2tmaWxsID0gY2FuY2VsO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YnNjcmlwdGlvbiBvZiB0aGlzLnZpcnR1YWxTdWJzY3JpcHRpb25zQnlJZC52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgdm9pZCAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVzdWJzY3JpYmVBbmRCYWNrZmlsbChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWxsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgYmFja2ZpbGxpbmcgXCIke3N1YnNjcmlwdGlvbi5wYXJhbXNbMF19XCIgc3Vic2NyaXB0aW9uLiBTb21lIGV2ZW50cyBtYXkgYmUgbWlzc2luZy5gLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KSkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW5jZWxzIHRoZSBoZWFydGJlYXQgYW5kIGFueSBwZW5kaW5nIGJhY2tmaWxscyBiZWluZyBwZXJmb3JtZWQuIFRoaXMgaXNcclxuICAgICAgICAgKiBjYWxsZWQgd2hlbiB0aGUgd2Vic29ja2V0IGNvbm5lY3Rpb24gZ29lcyBkb3duIG9yIGlzIGRpc2Nvbm5lY3RlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSBmaWVsZCBhcnJvdyBmdW5jdGlvbiBpbiBvcmRlciB0byBwcmVzZXJ2ZSBgdGhpc2AgY29udGV4dCB3aGVuXHJcbiAgICAgICAgICogcGFzc2luZyB0aGUgbWV0aG9kIGFzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbElkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xyXG4gICAgICAgIC8vIFN0YXJ0IGhlYXJ0YmVhdCBhbmQgYmFja2ZpbGxlciBmb3IgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uLlxyXG4gICAgICAgIHRoaXMuYmFja2ZpbGxlciA9IG5ldyBXZWJzb2NrZXRCYWNrZmlsbGVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWRkU29ja2V0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zdGFydEhlYXJ0YmVhdCgpO1xyXG4gICAgICAgIHRoaXMuY2FuY2VsQmFja2ZpbGwgPSBub29wO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBCYXNlUHJvdmlkZXIuZ2V0TmV0d29ya2AgbWV0aG9kIGFzIGltcGxlbWVudGVkIGJ5IGV0aGVycy5qcy5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG92ZXJyaWRlIGFsbG93cyB0aGUgU0RLIHRvIHNldCB0aGUgcHJvdmlkZXIncyBuZXR3b3JrIHRvIHZhbHVlcyBub3RcclxuICAgICAqIHlldCBzdXBwb3J0ZWQgYnkgZXRoZXJzLmpzLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXROZXR3b3JrKG5ldHdvcmspIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdzdHJpbmcnICYmIG5ldHdvcmsgaW4gQ3VzdG9tTmV0d29ya3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbU5ldHdvcmtzW25ldHdvcmtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxsIHRoZSBzdGFuZGFyZCBldGhlcnMuanMgZ2V0TmV0d29yayBtZXRob2QgZm9yIG90aGVyIG5ldHdvcmtzLlxyXG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKG5ldHdvcmspO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIGltcGxlbWVudGF0aW9uIG9mIGV0aGVycyB0aGF0IGluY2x1ZGVzIEFsY2hlbXkgYmFzZWQgc3Vic2NyaXB0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBPdmVycmlkZSBgTGlzdGVuZXJgIHR5cGUgdG8gZ2V0IHR5cGUgYXV0b2NvbXBsZXRpb25zLlxyXG4gICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBpbXBsZW1lbnRhdGlvbiBvZiBldGhlcnMgdGhhdCBpbmNsdWRlcyBBbGNoZW15IGJhc2VkXHJcbiAgICAgKiBzdWJzY3JpcHRpb25zLiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIHRyaWdnZXJlZCBmb3Igb25seSB0aGUgbmV4dFxyXG4gICAgICoge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQsIGFmdGVyIHdoaWNoIGl0IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIEV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICAvLyBUT0RPOiBPdmVycmlkZSBgTGlzdGVuZXJgIHR5cGUgdG8gZ2V0IHR5cGUgYXV0b2NvbXBsZXRpb25zLlxyXG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHByb3ZpZGVkIHtAbGluayBsaXN0ZW5lcn0gZm9yIHRoZSB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm9cclxuICAgICAqIGxpc3RlbmVyIGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgRXZlbnQgdG8gdW5saXN0ZW4gdG8uXHJcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZS5cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICovXHJcbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmIChpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWYgbm8gZXZlbnRcclxuICAgICAqIGlzIHByb3ZpZGVkLCBhbGwgZXZlbnRzIGFuZCB0aGVpciBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcHVibGljXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvciB0aGUgcHJvdmlkZWQge0BsaW5rIGV2ZW50TmFtZX0gZXZlbnQuIElmXHJcbiAgICAgKiBubyBldmVudCBpcyBwcm92aWRlZCwgdGhlIHRvdGFsIG51bWJlciBvZiBsaXN0ZW5lcnMgZm9yIGFsbCBldmVudHMgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGZvci5cclxuICAgICAqIEBwdWJsaWNcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09IHVuZGVmaW5lZCAmJiBpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lckNvdW50KGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJDb3VudChldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBwcm92aWRlZCB7QGxpbmsgZXZlbnROYW1lfSBldmVudC4gSWZcclxuICAgICAqIG5vIGV2ZW50IGlzIHByb3ZpZGVkLCBhbGwgbGlzdGVuZXJzIHdpbGwgYmUgaW5jbHVkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgZXZlbnQgdG8gZ2V0IHRoZSBsaXN0ZW5lcnMgZm9yLlxyXG4gICAgICogQHB1YmxpY1xyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQgJiYgaXNBbGNoZW15RXZlbnQoZXZlbnROYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIubGlzdGVuZXJzKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIG1ldGhvZCBpbiBgQmFzZVByb3ZpZGVyYCBpbiBvcmRlciB0byBwcm9wZXJseSBmb3JtYXQgdGhlXHJcbiAgICAgKiBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xyXG4gICAgICAgIGlmIChpc0FsY2hlbXlFdmVudChldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgIHZlcmlmeUFsY2hlbXlFdmVudE5hbWUoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXRoZXJzRXZlbnQoZ2V0QWxjaGVteUV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGBfc3RhcnRFdmVudCgpYCBtZXRob2QgaW4gZXRoZXJzLmpzJ3NcclxuICAgICAqIHtAbGluayBXZWJTb2NrZXRQcm92aWRlcn0gdG8gaW5jbHVkZSBhZGRpdGlvbmFsIGFsY2hlbXkgbWV0aG9kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IHR5cGUgaXMgYSBjdXN0b20gQWxjaGVteSBzdWJzY3JpcHRpb24uXHJcbiAgICAgICAgY29uc3QgY3VzdG9tTG9naWNUeXBlcyA9IFtcclxuICAgICAgICAgICAgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFLFxyXG4gICAgICAgICAgICAnYmxvY2snLFxyXG4gICAgICAgICAgICAnZmlsdGVyJ1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgaWYgKGN1c3RvbUxvZ2ljVHlwZXMuaW5jbHVkZXMoZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXN0b21TdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN1cGVyLl9zdGFydEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gZnJvbSBldGhlcnMuanMncyB7QGxpbmsgV2ViU29ja2V0UHJvdmlkZXJ9XHJcbiAgICAgKlxyXG4gICAgICogTW9kaWZpZWQgaW4gb3JkZXIgdG8gYWRkIG1hcHBpbmdzIGZvciBiYWNrZmlsbGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBfc3Vic2NyaWJlKHRhZywgcGFyYW0sIHByb2Nlc3NGdW5jLCBldmVudCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICAgICAgLy8gQkVHSU4gTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBjb25zdCBzdGFydGluZ0Jsb2NrTnVtYmVyID0geWllbGQgdGhpcy5nZXRCbG9ja051bWJlcigpO1xyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBpZiAoc3ViSWRQcm9taXNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcmFtKS50aGVuKHBhcmFtID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKCdldGhfc3Vic2NyaWJlJywgcGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJJZHNbdGFnXSA9IHN1YklkUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IHlpZWxkIHN1YklkUHJvbWlzZTtcclxuICAgICAgICAgICAgLy8gQkVHSU4gTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhcmFtcyA9IHlpZWxkIFByb21pc2UuYWxsKHBhcmFtKTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuc2V0KHN1YklkLCB7XHJcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXHJcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfc3Vic2NyaWJlJyxcclxuICAgICAgICAgICAgICAgIHBhcmFtczogcmVzb2x2ZWRQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICBzdGFydGluZ0Jsb2NrTnVtYmVyLFxyXG4gICAgICAgICAgICAgICAgdmlydHVhbElkOiBzdWJJZCxcclxuICAgICAgICAgICAgICAgIHBoeXNpY2FsSWQ6IHN1YklkLFxyXG4gICAgICAgICAgICAgICAgc2VudEV2ZW50czogW10sXHJcbiAgICAgICAgICAgICAgICBpc0JhY2tmaWxsaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyOiBbXVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLnNldChzdWJJZCwgc3ViSWQpO1xyXG4gICAgICAgICAgICAvLyBFTkQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgICAgICB0aGlzLl9zdWJzW3N1YklkXSA9IHsgdGFnLCBwcm9jZXNzRnVuYyB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXJgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKGlzQWxjaGVteUV2ZW50KGV2ZW50TmFtZSkpIHtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbGluZSBpcyB0aGUgb25seSBtb2RpZmllZCBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIG1ldGhvZC5cclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzdG9wcGVkLmZvckVhY2goZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHNlbmRCYXRjaChwYXJ0cykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGxldCBuZXh0SWQgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcGFydHMubWFwKCh7IG1ldGhvZCwgcGFyYW1zIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcclxuICAgICAgICAgICAgICAgICAgICBpZDogYGFsY2hlbXktc2RrOiR7bmV4dElkKyt9YFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5zZW5kQmF0Y2hDb25jdXJyZW50bHkocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSByZXNwb25zZS5maW5kKHIgPT4gISFyLmVycm9yKTtcclxuICAgICAgICAgICAgaWYgKGVycm9yUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRoZSBpZHMgYXJlIGFzY2VuZGluZyBudW1iZXJzIGJlY2F1c2UgdGhhdCdzIHdoYXQgUGF5bG9hZCBGYWN0b3JpZXMgZG8uXHJcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgLnNvcnQoKHIxLCByMikgPT4gcjEuaWQgLSByMi5pZClcclxuICAgICAgICAgICAgICAgIC5tYXAociA9PiByLnJlc3VsdCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQG92ZXJyaWRlICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlU29ja2V0TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0QW5kQmFja2ZpbGwoKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZXMgdGhlIGV0aGVyJ3MgYGlzQ29tbXVuaXR5UmVzb3VyY2UoKWAgbWV0aG9kLiBSZXR1cm5zIHRydWUgaWYgdGhlXHJcbiAgICAgKiBjdXJyZW50IGFwaSBrZXkgaXMgdGhlIGRlZmF1bHQga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwaUtleSA9PT0gREVGQVVMVF9BTENIRU1ZX0FQSV9LRVk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYFdlYlNvY2tldFByb3ZpZGVyLl9zdG9wRXZlbnQoKWAuXHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgY29waWVkIG92ZXIgZGlyZWN0bHkgaW4gb3JkZXIgdG8gc3VwcG9ydCBBbGNoZW15J3NcclxuICAgICAqIHN1YnNjcmlwdGlvbiB0eXBlIGJ5IGFsbG93aW5nIHRoZSBwcm92aWRlciB0byBwcm9wZXJseSBzdG9wIEFsY2hlbXknc1xyXG4gICAgICogc3Vic2NyaXB0aW9uIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3N0b3BFdmVudChldmVudCkge1xyXG4gICAgICAgIGxldCB0YWcgPSBldmVudC50YWc7XHJcbiAgICAgICAgLy8gU1RBUlQgTU9ESUZJRUQgQ09ERVxyXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBwZW5kaW5nIHRyYW5zYWN0aW9uIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50cy5maWx0ZXIoZSA9PiBlLnR5cGUgPT09IEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfVFlQRSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRU5EIE1PRElGSUVEIENPREVcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3R4Jykge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIHRyYW5zYWN0aW9uIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcihlID0+IGUudHlwZSA9PT0gJ3R4JykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFnID0gJ3R4JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KGV2ZW50LmV2ZW50KSkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgcmVtYWluaW5nIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN1YklkID0gdGhpcy5fc3ViSWRzW3RhZ107XHJcbiAgICAgICAgaWYgKCFzdWJJZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcclxuICAgICAgICB2b2lkIHN1YklkLnRoZW4oc3ViSWQgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N1YnNbc3ViSWRdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNbc3ViSWRdO1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuc2VuZCgnZXRoX3Vuc3Vic2NyaWJlJywgW3N1YklkXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBhZGRTb2NrZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZU1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdyZW9wZW4nLCB0aGlzLmhhbmRsZVJlb3Blbik7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Rvd24nLCB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICByZW1vdmVTb2NrZXRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZU1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZW9wZW4nLCB0aGlzLmhhbmRsZVJlb3Blbik7XHJcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rvd24nLCB0aGlzLnN0b3BIZWFydGJlYXRBbmRCYWNrZmlsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlb3BlbnMgdGhlIGJhY2tmaWxsIGJhc2VkIG9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlzQ2FuY2VsbGVkXHJcbiAgICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcmVzdWJzY3JpYmVBbmRCYWNrZmlsbChpc0NhbmNlbGxlZCwgc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgeyB2aXJ0dWFsSWQsIG1ldGhvZCwgcGFyYW1zLCBzZW50RXZlbnRzLCBiYWNrZmlsbEJ1ZmZlciwgc3RhcnRpbmdCbG9ja051bWJlciB9ID0gc3Vic2NyaXB0aW9uO1xyXG4gICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNCYWNrZmlsbGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGJhY2tmaWxsQnVmZmVyLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaHlzaWNhbElkID0geWllbGQgdGhpcy5zZW5kKG1ldGhvZCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIHRocm93SWZDYW5jZWxsZWQoaXNDYW5jZWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnBoeXNpY2FsSWQgPSBwaHlzaWNhbElkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aXJ0dWFsSWRzQnlQaHlzaWNhbElkLnNldChwaHlzaWNhbElkLCB2aXJ0dWFsSWQpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbXNbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICduZXdIZWFkcyc6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja2ZpbGxFdmVudHMgPSB5aWVsZCB3aXRoQmFja29mZlJldHJpZXMoKCkgPT4gd2l0aFRpbWVvdXQodGhpcy5iYWNrZmlsbGVyLmdldE5ld0hlYWRzQmFja2ZpbGwoaXNDYW5jZWxsZWQsIHNlbnRFdmVudHMsIHN0YXJ0aW5nQmxvY2tOdW1iZXIpLCBCQUNLRklMTF9USU1FT1VUKSwgQkFDS0ZJTExfUkVUUklFUywgKCkgPT4gIWlzQ2FuY2VsbGVkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkKGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gZGVkdXBlTmV3SGVhZHMoWy4uLmJhY2tmaWxsRXZlbnRzLCAuLi5iYWNrZmlsbEJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVtaXROZXdIZWFkc0V2ZW50KHZpcnR1YWxJZCwgZXZlbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xvZ3MnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHBhcmFtc1sxXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja2ZpbGxFdmVudHMgPSB5aWVsZCB3aXRoQmFja29mZlJldHJpZXMoKCkgPT4gd2l0aFRpbWVvdXQodGhpcy5iYWNrZmlsbGVyLmdldExvZ3NCYWNrZmlsbChpc0NhbmNlbGxlZCwgZmlsdGVyLCBzZW50RXZlbnRzLCBzdGFydGluZ0Jsb2NrTnVtYmVyKSwgQkFDS0ZJTExfVElNRU9VVCksIEJBQ0tGSUxMX1JFVFJJRVMsICgpID0+ICFpc0NhbmNlbGxlZCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZChpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IGRlZHVwZUxvZ3MoWy4uLmJhY2tmaWxsRXZlbnRzLCAuLi5iYWNrZmlsbEJ1ZmZlcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB0aGlzLmVtaXRMb2dzRXZlbnQodmlydHVhbElkLCBldmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uaXNCYWNrZmlsbGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYmFja2ZpbGxCdWZmZXIubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgZW1pdE5ld0hlYWRzRXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXROZXdIZWFkc0Jsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRMb2dzRXZlbnQodmlydHVhbElkLCByZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhbiBldmVudCB0byBjb25zdW1lcnMsIGJ1dCBhbHNvIHJlbWVtYmVycyBpdCBpbiBpdHMgc3Vic2NyaXB0aW9ucydzXHJcbiAgICAgKiBgc2VudEV2ZW50c2AgYnVmZmVyIHNvIHRoYXQgd2UgY2FuIGRldGVjdCByZS1vcmdzIGlmIHRoZSBjb25uZWN0aW9uIGRyb3BzXHJcbiAgICAgKiBhbmQgbmVlZHMgdG8gYmUgcmVjb25uZWN0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIGVtaXRBbmRSZW1lbWJlckV2ZW50KHZpcnR1YWxJZCwgcmVzdWx0LCBnZXRCbG9ja051bWJlcikge1xyXG4gICAgICAgIHRoaXMucmVtZW1iZXJFdmVudCh2aXJ0dWFsSWQsIHJlc3VsdCwgZ2V0QmxvY2tOdW1iZXIpO1xyXG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbFN1YnNjcmlwdGlvbnNCeUlkLmdldCh2aXJ0dWFsSWQpO1xyXG4gICAgICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbWl0R2VuZXJpY0V2ZW50KHN1YnNjcmlwdGlvbiwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIHJlbWVtYmVyRXZlbnQodmlydHVhbElkLCByZXN1bHQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy52aXJ0dWFsU3Vic2NyaXB0aW9uc0J5SWQuZ2V0KHZpcnR1YWxJZCk7XHJcbiAgICAgICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZWIzIG1vZGlmaWVzIHRoZXNlIGV2ZW50IG9iamVjdHMgb25jZSB3ZSBwYXNzIHRoZW0gb24gKGNoYW5naW5nIGhleFxyXG4gICAgICAgIC8vIG51bWJlcnMgdG8gbnVtYmVycykuIFdlIHdhbnQgdGhlIG9yaWdpbmFsIGV2ZW50LCBzbyBtYWtlIGEgZGVmZW5zaXZlXHJcbiAgICAgICAgLy8gY29weS5cclxuICAgICAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIoc3Vic2NyaXB0aW9uLnNlbnRFdmVudHMsIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCksIGdldEJsb2NrTnVtYmVyKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW50ZXJuYWwgKi9cclxuICAgIGVtaXRHZW5lcmljRXZlbnQoc3Vic2NyaXB0aW9uLCByZXN1bHQpIHtcclxuICAgICAgICBjb25zdCBlbWl0RnVuY3Rpb24gPSB0aGlzLmVtaXRQcm9jZXNzRm4oc3Vic2NyaXB0aW9uLmV2ZW50KTtcclxuICAgICAgICBlbWl0RnVuY3Rpb24ocmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgaGVhcnRiZWF0IHRoYXQgcGluZ3MgdGhlIHdlYnNvY2tldCBzZXJ2ZXIgcGVyaW9kaWNhbGx5IHRvIGVuc3VyZVxyXG4gICAgICogdGhhdCB0aGUgY29ubmVjdGlvbiBzdGF5cyBvcGVuLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGFydEhlYXJ0YmVhdCgpIHtcclxuICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRJbnRlcnZhbElkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB3aXRoVGltZW91dCh0aGlzLnNlbmQoJ25ldF92ZXJzaW9uJyksIEhFQVJUQkVBVF9XQUlUX1RJTUUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LnJlY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksIEhFQVJUQkVBVF9JTlRFUlZBTCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHNlbmRzIHRoZSBiYXRjaCBjb25jdXJyZW50bHkgYXMgaW5kaXZpZHVhbCByZXF1ZXN0cyByYXRoZXIgdGhhblxyXG4gICAgICogYXMgYSBiYXRjaCwgd2hpY2ggd2FzIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbi4gVGhlIG9yaWdpbmFsIGJhdGNoIGxvZ2ljXHJcbiAgICAgKiBpcyBwcmVzZXJ2ZWQgaW4gdGhpcyBpbXBsZW1lbnRhdGlvbiBpbiBvcmRlciBmb3IgZmFzdGVyIHBvcnRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBheWxvYWRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvLyBUT0RPKGNsZWFudXApOiBSZWZhY3RvciBhbmQgcmVtb3ZlIHVzYWdlcyBvZiBgc2VuZEJhdGNoKClgLlxyXG4gICAgLy8gVE9ETyhlcnJvcnMpOiBVc2UgYWxsU2V0dGxlZCgpIG9uY2Ugd2UgaGF2ZSBtb3JlIGVycm9yIGhhbmRsaW5nLlxyXG4gICAgc2VuZEJhdGNoQ29uY3VycmVudGx5KHBheWxvYWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocGF5bG9hZC5tYXAocmVxID0+IHRoaXMuc2VuZChyZXEubWV0aG9kLCByZXEucGFyYW1zKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xyXG4gICAgY3VzdG9tU3RhcnRFdmVudChldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBoYXNoZXNPbmx5IH0gPSBldmVudDtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXHJcbiAgICAgICAgICAgICAgICBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX01FVEhPRCxcclxuICAgICAgICAgICAgICAgIHsgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgaGFzaGVzT25seSB9XHJcbiAgICAgICAgICAgIF0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2Jsb2NrJykge1xyXG4gICAgICAgICAgICB2b2lkIHRoaXMuX3N1YnNjcmliZSgnYmxvY2snLCBbJ25ld0hlYWRzJ10sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2ZpbHRlcicpIHtcclxuICAgICAgICAgICAgdm9pZCB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbJ2xvZ3MnLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIHRoaXMuZW1pdFByb2Nlc3NGbihldmVudCksIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICBlbWl0UHJvY2Vzc0ZuKGV2ZW50KSB7XHJcbiAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9UWVBFOlxyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBmcm9tQWRkcmVzcywgdG9BZGRyZXNzLCBoYXNoZXNPbmx5IH0gPSBldmVudDtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPT4gdGhpcy5lbWl0KHtcclxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IEFMQ0hFTVlfUEVORElOR19UUkFOU0FDVElPTlNfRVZFTlRfTUVUSE9ELFxyXG4gICAgICAgICAgICAgICAgICAgIGZyb21BZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvQWRkcmVzcyxcclxuICAgICAgICAgICAgICAgICAgICBoYXNoZXNPbmx5XHJcbiAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xyXG4gICAgICAgICAgICBjYXNlICdibG9jayc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IEJpZ051bWJlci5mcm9tKHJlc3VsdC5udW1iZXIpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnYmxvY2snLCBibG9ja051bWJlcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlICdmaWx0ZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBldmVudCB0eXBlIHRvIGBlbWl0UHJvY2Vzc0ZuKClgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIub2ZmKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcgfHwgZXZlbnQubGlzdGVuZXIgIT0gbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRE8gTk9UIE1PRElGWS5cclxuICAgICAqXHJcbiAgICAgKiBPcmlnaW5hbCBjb2RlIGNvcGllZCBvdmVyIGZyb20gZXRoZXIuanMncyBgQmFzZVByb3ZpZGVyLnJlbW92ZUFsbExpc3RlbmVycygpYC5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjb3BpZWQgb3ZlciBkaXJlY3RseSBpbiBvcmRlciB0byBpbXBsZW1lbnQgQWxjaGVteSdzIHVuaXF1ZVxyXG4gICAgICogc3Vic2NyaXB0aW9uIHR5cGVzLiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgdGhpcyBtZXRob2QgY2FsbHNcclxuICAgICAqIHtAbGluayBnZXRBbGNoZW15RXZlbnRUYWd9IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGBnZXRFdmVudFRhZygpYCBtZXRob2QgaW5cclxuICAgICAqIG9yZGVyIHRvIHBhcnNlIHRoZSBBbGNoZW15IHN1YnNjcmlwdGlvbiBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0aGlzLl9ldmVudHM7XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihldmVudCA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaChldmVudCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BFdmVudChldmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERPIE5PVCBNT0RJRlkuXHJcbiAgICAgKlxyXG4gICAgICogT3JpZ2luYWwgY29kZSBjb3BpZWQgb3ZlciBmcm9tIGV0aGVyLmpzJ3MgYEJhc2VQcm92aWRlci5saXN0ZW5lckNvdW50KClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9saXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEFsY2hlbXlFdmVudFRhZyhldmVudE5hbWUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnRhZyA9PT0gZXZlbnRUYWc7XHJcbiAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBETyBOT1QgTU9ESUZZLlxyXG4gICAgICpcclxuICAgICAqIE9yaWdpbmFsIGNvZGUgY29waWVkIG92ZXIgZnJvbSBldGhlci5qcydzIGBCYXNlUHJvdmlkZXIubGlzdGVuZXJzKClgLlxyXG4gICAgICpcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNvcGllZCBvdmVyIGRpcmVjdGx5IGluIG9yZGVyIHRvIGltcGxlbWVudCBBbGNoZW15J3MgdW5pcXVlXHJcbiAgICAgKiBzdWJzY3JpcHRpb24gdHlwZXMuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB0aGlzIG1ldGhvZCBjYWxsc1xyXG4gICAgICoge0BsaW5rIGdldEFsY2hlbXlFdmVudFRhZ30gaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgYGdldEV2ZW50VGFnKClgIG1ldGhvZCBpblxyXG4gICAgICogb3JkZXIgdG8gcGFyc2UgdGhlIEFsY2hlbXkgc3Vic2NyaXB0aW9uIGV2ZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9saXN0ZW5lcnMoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKGV2ZW50ID0+IGV2ZW50Lmxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnROYW1lKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzXHJcbiAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT4gZXZlbnQudGFnID09PSBldmVudFRhZylcclxuICAgICAgICAgICAgLm1hcChldmVudCA9PiBldmVudC5saXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2Vic29ja2V0Q29uc3RydWN0b3IoKSB7XHJcbiAgICByZXR1cm4gaXNOb2RlRW52aXJvbm1lbnQoKSA/IHJlcXVpcmUoJ3dlYnNvY2tldCcpLnczY3dlYnNvY2tldCA6IFdlYlNvY2tldDtcclxufVxyXG5mdW5jdGlvbiBpc05vZGVFbnZpcm9ubWVudCgpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgcHJvY2VzcyAhPSBudWxsICYmXHJcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucyAhPSBudWxsICYmXHJcbiAgICAgICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlICE9IG51bGwpO1xyXG59XHJcbi8vIFRPRE8oY2xlYW51cCk6IFVzZSBjbGFzcyB2YXJpYWJsZSByYXRoZXIgdGhhbiBwYXNzaW5nIGBpc0NhbmNlbGxlZGAgZXZlcnl3aGVyZS5cclxuZnVuY3Rpb24gbWFrZUNhbmNlbFRva2VuKCkge1xyXG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHsgY2FuY2VsOiAoKSA9PiAoY2FuY2VsbGVkID0gdHJ1ZSksIGlzQ2FuY2VsbGVkOiAoKSA9PiBjYW5jZWxsZWQgfTtcclxufVxyXG4vLyBUT0RPKGNsZWFudXApOiByZXBsYWNlIHdpdGggU0RLJ3MgYmFja29mZiBpbXBsZW1lbnRhdGlvblxyXG5jb25zdCBNSU5fUkVUUllfREVMQVkgPSAxMDAwO1xyXG5jb25zdCBSRVRSWV9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XHJcbmNvbnN0IE1BWF9SRVRSWV9ERUxBWSA9IDMwMDAwO1xyXG5mdW5jdGlvbiB3aXRoQmFja29mZlJldHJpZXMoZiwgcmV0cnlDb3VudCwgc2hvdWxkUmV0cnkgPSAoKSA9PiB0cnVlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgIGxldCBuZXh0V2FpdFRpbWUgPSAwO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIGlmIChpID49IHJldHJ5Q291bnQgfHwgIXNob3VsZFJldHJ5KGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeWllbGQgZGVsYXkobmV4dFdhaXRUaW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBuZXh0V2FpdFRpbWUgPVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRXYWl0VGltZSA9PT0gMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1JTl9SRVRSWV9ERUxBWVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE1hdGgubWluKE1BWF9SRVRSWV9ERUxBWSwgUkVUUllfQkFDS09GRl9GQUNUT1IgKiBuZXh0V2FpdFRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZGVsYXkobXMpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcclxufVxyXG5mdW5jdGlvbiB3aXRoVGltZW91dChwcm9taXNlLCBtcykge1xyXG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbXHJcbiAgICAgICAgcHJvbWlzZSxcclxuICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQnKSksIG1zKSlcclxuICAgIF0pO1xyXG59XHJcbmZ1bmN0aW9uIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIoZXZlbnQpIHtcclxuICAgIHJldHVybiBmcm9tSGV4KGV2ZW50Lm51bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TG9nc0Jsb2NrTnVtYmVyKGV2ZW50KSB7XHJcbiAgICByZXR1cm4gZnJvbUhleChldmVudC5ibG9ja051bWJlcik7XHJcbn1cclxuZnVuY3Rpb24gaXNSZXNwb25zZShtZXNzYWdlKSB7XHJcbiAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkobWVzc2FnZSkgfHxcclxuICAgICAgICAobWVzc2FnZS5qc29ucnBjID09PSAnMi4wJyAmJiBtZXNzYWdlLmlkICE9PSB1bmRlZmluZWQpKTtcclxufVxyXG5mdW5jdGlvbiBpc1N1YnNjcmlwdGlvbkV2ZW50KG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiAhaXNSZXNwb25zZShtZXNzYWdlKTtcclxufVxyXG5mdW5jdGlvbiBhZGRUb05ld0hlYWRzRXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50KSB7XHJcbiAgICBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldE5ld0hlYWRzQmxvY2tOdW1iZXIpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFRvTG9nc0V2ZW50c0J1ZmZlcihwYXN0RXZlbnRzLCBldmVudCkge1xyXG4gICAgYWRkVG9QYXN0RXZlbnRzQnVmZmVyKHBhc3RFdmVudHMsIGV2ZW50LCBnZXRMb2dzQmxvY2tOdW1iZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIGEgbmV3IGV2ZW50IHRvIGFuIGFycmF5IG9mIGV2ZW50cywgZXZpY3RpbmcgYW55IGV2ZW50cyB3aGljaCBhcmUgc28gb2xkXHJcbiAqIHRoYXQgdGhleSB3aWxsIG5vIGxvbmdlciBmZWFzaWJseSBiZSBwYXJ0IG9mIGEgcmVvcmcuXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUb1Bhc3RFdmVudHNCdWZmZXIocGFzdEV2ZW50cywgZXZlbnQsIGdldEJsb2NrTnVtYmVyKSB7XHJcbiAgICBjb25zdCBjdXJyZW50QmxvY2tOdW1iZXIgPSBnZXRCbG9ja051bWJlcihldmVudCk7XHJcbiAgICAvLyBGaW5kIGZpcnN0IGluZGV4IG9mIGFuIGV2ZW50IHJlY2VudCBlbm91Z2ggdG8gcmV0YWluLCB0aGVuIGRyb3AgZXZlcnl0aGluZ1xyXG4gICAgLy8gYXQgYSBsb3dlciBpbmRleC5cclxuICAgIGNvbnN0IGZpcnN0R29vZEluZGV4ID0gcGFzdEV2ZW50cy5maW5kSW5kZXgoZSA9PiBnZXRCbG9ja051bWJlcihlKSA+IGN1cnJlbnRCbG9ja051bWJlciAtIFJFVEFJTkVEX0VWRU5UX0JMT0NLX0NPVU5UKTtcclxuICAgIGlmIChmaXJzdEdvb2RJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICBwYXN0RXZlbnRzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXN0RXZlbnRzLnNwbGljZSgwLCBmaXJzdEdvb2RJbmRleCk7XHJcbiAgICB9XHJcbiAgICBwYXN0RXZlbnRzLnB1c2goZXZlbnQpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQWxjaGVteUV2ZW50KGV2ZW50KSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0JyAmJiAnbWV0aG9kJyBpbiBldmVudDtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBgYWxjaGVteV9wZW5kaW5nVHJhbnNhY3Rpb25gXHJcbiAqIHN1YnNjcmlwdGlvbiBmaWx0ZXIgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggdGhlIGV0aGVycyBpbXBsZW1lbnRhdGlvbiBvZlxyXG4gKiBgZ2V0RXZlbnRUYWcoKWAuIFRoZSBtZXRob2QgaXMgbm90IGFuIGV4cG9ydGVkIGZ1bmN0aW9uIGluIGV0aGVycywgd2hpY2ggaXNcclxuICogd2h5IHRoZSBTREsgaGFzIGl0cyBvd24gaW1wbGVtZW50YXRpb24uXHJcbiAqXHJcbiAqIFRoZSBldmVudCB0YWcgaXMgdGhlbiBkZXNlcmlhbGl6ZWQgYnkgdGhlIFNESydzIHtAbGluayBFdGhlcnNFdmVudH0gZ2V0dGVycy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogICBgYGBqc1xyXG4gKiAgIC8vIFJldHVybnMgJ2FsY2hlbXktcGVuZGluZy10cmFuc2FjdGlvbnM6MHhBQkM6MHhERUZ8MHhHSEk6dHJ1ZSdcclxuICogICBjb25zdCBldmVudFRhZyA9ICBnZXRBbGNoZW15RXZlbnRUYWcoXHJcbiAqICAge1xyXG4gKiAgICAgXCJtZXRob2RcIjogXCJhbGNoZW15X3BlbmRpbmdUcmFuc2FjdGlvblwiLFxyXG4gKiAgICAgXCJmcm9tQWRkcmVzc1wiOiBcIjB4QUJDXCIsXHJcbiAqICAgICBcInRvQWRkcmVzc1wiOiBbXCIweERFRlwiLCBcIjB4R0hJXCJdLFxyXG4gKiAgICAgXCJoYXNoZXNPbmx5OiB0cnVlXHJcbiAqICAgfSk7XHJcbiAqICAgYGBgO1xyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBbGNoZW15RXZlbnRUYWcoZXZlbnQpIHtcclxuICAgIGlmICghaXNBbGNoZW15RXZlbnQoZXZlbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCB0YWcgcmVxdWlyZXMgQWxjaGVteUV2ZW50VHlwZScpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZnJvbUFkZHJlc3MgPSBzZXJpYWxpemVBZGRyZXNzRmllbGQoZXZlbnQuZnJvbUFkZHJlc3MpO1xyXG4gICAgY29uc3QgdG9BZGRyZXNzID0gc2VyaWFsaXplQWRkcmVzc0ZpZWxkKGV2ZW50LnRvQWRkcmVzcyk7XHJcbiAgICBjb25zdCBoYXNoZXNPbmx5ID0gc2VyaWFsaXplQm9vbGVhbkZpZWxkKGV2ZW50Lmhhc2hlc09ubHkpO1xyXG4gICAgcmV0dXJuIChBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX1RZUEUgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgZnJvbUFkZHJlc3MgK1xyXG4gICAgICAgICc6JyArXHJcbiAgICAgICAgdG9BZGRyZXNzICtcclxuICAgICAgICAnOicgK1xyXG4gICAgICAgIGhhc2hlc09ubHkpO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFkZHJlc3NGaWVsZChmaWVsZCkge1xyXG4gICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJyonO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcclxuICAgICAgICByZXR1cm4gZmllbGQuam9pbignfCcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZUJvb2xlYW5GaWVsZChmaWVsZCkge1xyXG4gICAgaWYgKGZpZWxkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gJyonO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGZpZWxkLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmVyaWZ5QWxjaGVteUV2ZW50TmFtZShldmVudE5hbWUpIHtcclxuICAgIGlmIChldmVudE5hbWUubWV0aG9kICE9PSBBTENIRU1ZX1BFTkRJTkdfVFJBTlNBQ1RJT05TX0VWRU5UX01FVEhPRCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgbmFtZSAke2V2ZW50TmFtZS5tZXRob2R9LiBBY2NlcHRlZCBtZXRob2QgbmFtZXM6ICR7QUxDSEVNWV9QRU5ESU5HX1RSQU5TQUNUSU9OU19FVkVOVF9NRVRIT0R9YCk7XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyLCBnZXRBbGNoZW15RXZlbnRUYWcgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFsY2hlbXktd2Vic29ja2V0LXByb3ZpZGVyLTQ4YmJiMGVkLmpzLm1hcFxuIiwidmFyIG5haXZlRmFsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdGlmICh0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBzZWxmKSByZXR1cm4gc2VsZjtcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93KSByZXR1cm4gd2luZG93O1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBnbG9iYWwgYHRoaXNgXCIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuXHRpZiAodGhpcykgcmV0dXJuIHRoaXM7XG5cblx0Ly8gVW5leHBlY3RlZCBzdHJpY3QgbW9kZSAobWF5IGhhcHBlbiBpZiBlLmcuIGJ1bmRsZWQgaW50byBFU00gbW9kdWxlKVxuXG5cdC8vIEZhbGxiYWNrIHRvIHN0YW5kYXJkIGdsb2JhbFRoaXMgaWYgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiAmJiBnbG9iYWxUaGlzKSByZXR1cm4gZ2xvYmFsVGhpcztcblxuXHQvLyBUaGFua3MgQG1hdGhpYXNieW5lbnMgLT4gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2dsb2JhbHRoaXNcblx0Ly8gSW4gYWxsIEVTNSsgZW5naW5lcyBnbG9iYWwgb2JqZWN0IGluaGVyaXRzIGZyb20gT2JqZWN0LnByb3RvdHlwZVxuXHQvLyAoaWYgeW91IGFwcHJvYWNoZWQgb25lIHRoYXQgZG9lc24ndCBwbGVhc2UgcmVwb3J0KVxuXHR0cnkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCBcIl9fZ2xvYmFsX19cIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gVW5mb3J0dW5hdGUgY2FzZSBvZiB1cGRhdGVzIHRvIE9iamVjdC5wcm90b3R5cGUgYmVpbmcgcmVzdHJpY3RlZFxuXHRcdC8vIHZpYSBwcmV2ZW50RXh0ZW5zaW9ucywgc2VhbCBvciBmcmVlemVcblx0XHRyZXR1cm4gbmFpdmVGYWxsYmFjaygpO1xuXHR9XG5cdHRyeSB7XG5cdFx0Ly8gU2FmYXJpIGNhc2UgKHdpbmRvdy5fX2dsb2JhbF9fIHdvcmtzLCBidXQgX19nbG9iYWxfXyBkb2VzIG5vdClcblx0XHRpZiAoIV9fZ2xvYmFsX18pIHJldHVybiBuYWl2ZUZhbGxiYWNrKCk7XG5cdFx0cmV0dXJuIF9fZ2xvYmFsX187XG5cdH0gZmluYWxseSB7XG5cdFx0ZGVsZXRlIE9iamVjdC5wcm90b3R5cGUuX19nbG9iYWxfXztcblx0fVxufSkoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNIT1VMRF9SRUNPTk5FQ1RfRkFMU0VfTUVTU0FHRSA9IFwiUHJvdmlkZWQgc2hvdWxkUmVjb25uZWN0KCkgcmV0dXJuZWQgZmFsc2UuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG52YXIgU0hPVUxEX1JFQ09OTkVDVF9QUk9NSVNFX0ZBTFNFX01FU1NBR0UgPSBcIlByb3ZpZGVkIHNob3VsZFJlY29ubmVjdCgpIHJlc29sdmVkIHRvIGZhbHNlLiBDbG9zaW5nIHBlcm1hbmVudGx5LlwiO1xudmFyIFN0dXJkeVdlYlNvY2tldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdHVyZHlXZWJTb2NrZXQodXJsLCBwcm90b2NvbHNPck9wdGlvbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMub25jbG9zZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbm9wZW4gPSBudWxsO1xuICAgICAgICB0aGlzLm9uZG93biA9IG51bGw7XG4gICAgICAgIHRoaXMub25yZW9wZW4gPSBudWxsO1xuICAgICAgICB0aGlzLkNPTk5FQ1RJTkcgPSBTdHVyZHlXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICAgICAgdGhpcy5PUEVOID0gU3R1cmR5V2ViU29ja2V0Lk9QRU47XG4gICAgICAgIHRoaXMuQ0xPU0lORyA9IFN0dXJkeVdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgICB0aGlzLkNMT1NFRCA9IFN0dXJkeVdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICAgIHRoaXMuaGFzQmVlbk9wZW5lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLm5leHRSZXRyeVRpbWUgPSAwO1xuICAgICAgICB0aGlzLnJlY29ubmVjdENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5sYXN0S25vd25FeHRlbnNpb25zID0gXCJcIjtcbiAgICAgICAgdGhpcy5sYXN0S25vd25Qcm90b2NvbCA9IFwiXCI7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIGlmIChwcm90b2NvbHNPck9wdGlvbnMgPT0gbnVsbCB8fFxuICAgICAgICAgICAgdHlwZW9mIHByb3RvY29sc09yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShwcm90b2NvbHNPck9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29scyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHNPck9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zID0gYXBwbHlEZWZhdWx0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMud3NDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMud3NDb25zdHJ1Y3RvciA9IFdlYlNvY2tldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldlYlNvY2tldCBub3QgcHJlc2VudCBpbiBnbG9iYWwgc2NvcGUgYW5kIG5vIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJ3c0NvbnN0cnVjdG9yIG9wdGlvbiB3YXMgcHJvdmlkZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3Blbk5ld1dlYlNvY2tldCgpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJiaW5hcnlUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgfHwgXCJibG9iXCI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuYmluYXJ5VHlwZUludGVybmFsID0gYmluYXJ5VHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gYmluYXJ5VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiYnVmZmVyZWRBbW91bnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSB0aGlzLndzID8gdGhpcy53cy5idWZmZXJlZEFtb3VudCA6IDA7XG4gICAgICAgICAgICB2YXIgaGFzVW5rbm93bkFtb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyLmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IGdldERhdGFCeXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYXNVbmtub3duQW1vdW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChoYXNVbmtub3duQW1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIlNvbWUgYnVmZmVyZWQgZGF0YSBoYWQgdW5rbm93biBsZW5ndGguIGJ1ZmZlcmVkQW1vdW50KClcIiArXG4gICAgICAgICAgICAgICAgICAgIFwiIHJldHVybiB2YWx1ZSBtYXkgYmUgYmVsb3cgdGhlIGNvcnJlY3QgYW1vdW50LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImV4dGVuc2lvbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndzID8gdGhpcy53cy5leHRlbnNpb25zIDogdGhpcy5sYXN0S25vd25FeHRlbnNpb25zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJwcm90b2NvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3MgPyB0aGlzLndzLnByb3RvY29sIDogdGhpcy5sYXN0S25vd25Qcm90b2NvbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwicmVhZHlTdGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNDbG9zZWQgPyBTdHVyZHlXZWJTb2NrZXQuQ0xPU0VEIDogU3R1cmR5V2ViU29ja2V0Lk9QRU47XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZVNvY2tldChjb2RlLCByZWFzb24pO1xuICAgICAgICB0aGlzLnNodXRkb3duKCk7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgcGVybWFuZW50bHkgY2xvc2VkIGJ5IGNsaWVudC5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViU29ja2V0IGlzIGFscmVhZHkgaW4gQ0xPU0lORyBvciBDTE9TRUQgc3RhdGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSB0aGlzLk9QRU4pIHtcbiAgICAgICAgICAgIHRoaXMud3Muc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5wdXNoKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIHJlY29ubmVjdCgpIG9uIHNvY2tldCB3aGljaCBpcyBwZXJtYW5lbnRseSBjbG9zZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcG9zZVNvY2tldCgxMDAwLCBcIkNsaWVudCByZXF1ZXN0ZWQgcmVjb25uZWN0LlwiKTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbG9zZSh1bmRlZmluZWQpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShldmVudC50eXBlLCBldmVudCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IHRoaXMubGlzdGVuZXJzW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbCAhPT0gbGlzdGVuZXI7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLm9wZW5OZXdXZWJTb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBjb25uZWN0VGltZW91dCA9IF9hLmNvbm5lY3RUaW1lb3V0LCB3c0NvbnN0cnVjdG9yID0gX2Eud3NDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIk9wZW5pbmcgbmV3IFdlYlNvY2tldCB0byBcIiArIHRoaXMudXJsICsgXCIuXCIpO1xuICAgICAgICB2YXIgd3MgPSBuZXcgd3NDb25zdHJ1Y3Rvcih0aGlzLnVybCwgdGhpcy5wcm90b2NvbHMpO1xuICAgICAgICB3cy5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVDbG9zZShldmVudCk7IH07XG4gICAgICAgIHdzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUVycm9yKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVNZXNzYWdlKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25vcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVPcGVuKGV2ZW50KTsgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHJ1bm5pbmcsIHdlIHN0aWxsIGhhdmVuJ3Qgb3BlbmVkIHRoZSB3ZWJzb2NrZXQuXG4gICAgICAgICAgICAvLyBLaWxsIGl0IHNvIHdlIGNhbiB0cnkgYWdhaW4uXG4gICAgICAgICAgICBfdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgICAgICBfdGhpcy5kaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVDbG9zZSh1bmRlZmluZWQpO1xuICAgICAgICB9LCBjb25uZWN0VGltZW91dCk7XG4gICAgICAgIHRoaXMud3MgPSB3cztcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlT3BlbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxDbGVhclJlc2V0VGltZSA9IHRoaXMub3B0aW9ucy5hbGxDbGVhclJlc2V0VGltZTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBvcGVuZWQuXCIpO1xuICAgICAgICBpZiAodGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IHRoaXMud3MuYmluYXJ5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQmVlbk9wZW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwicmVvcGVuXCIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcIm9wZW5cIiwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gX3RoaXMuc2VuZChtZXNzYWdlKTsgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgX3RoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgb3BlblRpbWUgPSAoYWxsQ2xlYXJSZXNldFRpbWUgLyAxMDAwKSB8IDA7XG4gICAgICAgICAgICBfdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCByZW1haW5lZCBvcGVuIGZvciBcIiArIG9wZW5UaW1lICsgXCIgc2Vjb25kcy4gUmVzZXR0aW5nXCIgK1xuICAgICAgICAgICAgICAgIFwiIHJldHJ5IHRpbWUgYW5kIGNvdW50LlwiKTtcbiAgICAgICAgfSwgYWxsQ2xlYXJSZXNldFRpbWUpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwibWVzc2FnZVwiLCBldmVudCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IF9hLm1heFJlY29ubmVjdEF0dGVtcHRzLCBzaG91bGRSZWNvbm5lY3QgPSBfYS5zaG91bGRSZWNvbm5lY3Q7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSB0aGlzLndzLmV4dGVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gdGhpcy53cy5wcm90b2NvbDtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcImRvd25cIiwgZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RDb3VudCA+PSBtYXhSZWNvbm5lY3RBdHRlbXB0cykge1xuICAgICAgICAgICAgdGhpcy5zdG9wUmVjb25uZWN0aW5nKGV2ZW50LCB0aGlzLmdldFRvb01hbnlGYWlsZWRSZWNvbm5lY3RzTWVzc2FnZSgpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lsbFJlY29ubmVjdCA9ICFldmVudCB8fCBzaG91bGRSZWNvbm5lY3QoZXZlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbGxSZWNvbm5lY3QgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVdpbGxSZWNvbm5lY3Qod2lsbFJlY29ubmVjdCwgZXZlbnQsIFNIT1VMRF9SRUNPTk5FQ1RfRkFMU0VfTUVTU0FHRSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWxsUmVjb25uZWN0LnRoZW4oZnVuY3Rpb24gKHdpbGxSZWNvbm5lY3RSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVdpbGxSZWNvbm5lY3Qod2lsbFJlY29ubmVjdFJlc29sdmVkLCBldmVudCwgU0hPVUxEX1JFQ09OTkVDVF9QUk9NSVNFX0ZBTFNFX01FU1NBR0UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZXJyb3JcIiwgZXZlbnQpO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKFwiV2ViU29ja2V0IGVuY291bnRlcmVkIGFuIGVycm9yLlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlV2lsbFJlY29ubmVjdCA9IGZ1bmN0aW9uICh3aWxsUmVjb25uZWN0LCBldmVudCwgZGVuaWFsUmVhc29uKSB7XG4gICAgICAgIGlmICh3aWxsUmVjb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlZXN0YWJsaXNoQ29ubmVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdG9wUmVjb25uZWN0aW5nKGV2ZW50LCBkZW5pYWxSZWFzb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnJlZXN0YWJsaXNoQ29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBtaW5SZWNvbm5lY3REZWxheSA9IF9hLm1pblJlY29ubmVjdERlbGF5LCBtYXhSZWNvbm5lY3REZWxheSA9IF9hLm1heFJlY29ubmVjdERlbGF5LCByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yID0gX2EucmVjb25uZWN0QmFja29mZkZhY3RvcjtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RDb3VudCsrO1xuICAgICAgICB2YXIgcmV0cnlUaW1lID0gdGhpcy5uZXh0UmV0cnlUaW1lO1xuICAgICAgICB0aGlzLm5leHRSZXRyeVRpbWUgPSBNYXRoLm1heChtaW5SZWNvbm5lY3REZWxheSwgTWF0aC5taW4odGhpcy5uZXh0UmV0cnlUaW1lICogcmVjb25uZWN0QmFja29mZkZhY3RvciwgbWF4UmVjb25uZWN0RGVsYXkpKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5vcGVuTmV3V2ViU29ja2V0KCk7IH0sIHJldHJ5VGltZSk7XG4gICAgICAgIHZhciByZXRyeVRpbWVTZWNvbmRzID0gKHJldHJ5VGltZSAvIDEwMDApIHwgMDtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCB3YXMgY2xvc2VkLiBSZS1vcGVuaW5nIGluIFwiICsgcmV0cnlUaW1lU2Vjb25kcyArIFwiIHNlY29uZHMuXCIpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5zdG9wUmVjb25uZWN0aW5nID0gZnVuY3Rpb24gKGV2ZW50LCBkZWJ1Z1JlYXNvbikge1xuICAgICAgICB0aGlzLmRlYnVnTG9nKGRlYnVnUmVhc29uKTtcbiAgICAgICAgdGhpcy5zaHV0ZG93bigpO1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcImNsb3NlXCIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxUaW1lb3V0cygpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNwb3NlU29ja2V0KCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3Bvc2VTb2NrZXQgPSBmdW5jdGlvbiAoY2xvc2VDb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLndzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIG5vb3AgaGFuZGxlcnMgaW5zdGVhZCBvZiBudWxsIGJlY2F1c2Ugc29tZSBXZWJTb2NrZXRcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb25zLCBzdWNoIGFzIHRoZSBvbmUgZnJvbSBpc29tb3JwaGljLXdzLCByYWlzZSBhIHN0aW5rIG9uXG4gICAgICAgIC8vIHVuaGFuZGxlZCBldmVudHMuXG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IG5vb3A7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IG5vb3A7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gbm9vcDtcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSBub29wO1xuICAgICAgICB0aGlzLndzLmNsb3NlKGNsb3NlQ29kZSwgcmVhc29uKTtcbiAgICAgICAgdGhpcy53cyA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJBbGxUaW1lb3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJDb25uZWN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckFsbENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5hbGxDbGVhclRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50T2ZUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubWVzc2FnZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbm9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25kb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25kb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVvcGVuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25yZW9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbnJlb3BlbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXVxuICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBfdGhpcy5jYWxsTGlzdGVuZXIobGlzdGVuZXIsIGV2ZW50KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFldmVudCB8fCAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2FsbExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGVidWdMb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSB0aGlzLm9wdGlvbnMubWF4UmVjb25uZWN0QXR0ZW1wdHM7XG4gICAgICAgIHJldHVybiBcIkZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgXCIgKyBtYXhSZWNvbm5lY3RBdHRlbXB0cyArIFwiIFwiICsgcGx1cmFsaXplKFwiYXR0ZW1wdFwiLCBtYXhSZWNvbm5lY3RBdHRlbXB0cykgKyBcIi4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5ERUZBVUxUX09QVElPTlMgPSB7XG4gICAgICAgIGFsbENsZWFyUmVzZXRUaW1lOiA1MDAwLFxuICAgICAgICBjb25uZWN0VGltZW91dDogNTAwMCxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBtaW5SZWNvbm5lY3REZWxheTogMTAwMCxcbiAgICAgICAgbWF4UmVjb25uZWN0RGVsYXk6IDMwMDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yOiAxLjUsXG4gICAgICAgIHNob3VsZFJlY29ubmVjdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgd3NDb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LkNPTk5FQ1RJTkcgPSAwO1xuICAgIFN0dXJkeVdlYlNvY2tldC5PUEVOID0gMTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ0xPU0lORyA9IDI7XG4gICAgU3R1cmR5V2ViU29ja2V0LkNMT1NFRCA9IDM7XG4gICAgcmV0dXJuIFN0dXJkeVdlYlNvY2tldDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHVyZHlXZWJTb2NrZXQ7XG5mdW5jdGlvbiBhcHBseURlZmF1bHRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OUykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgcmVzdWx0W2tleV0gPVxuICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OU1trZXldXG4gICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0RGF0YUJ5dGVMZW5ndGgoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBVVEYtMTYgc3RyaW5ncyB1c2UgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIuXG4gICAgICAgIHJldHVybiAyICogZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICByZXR1cm4gZGF0YS5zaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBwbHVyYWxpemUocywgbikge1xuICAgIHJldHVybiBuID09PSAxID8gcyA6IHMgKyBcInNcIjtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgLy8gTm90aGluZy5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsInZhciBfZ2xvYmFsVGhpcztcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHtcblx0X2dsb2JhbFRoaXMgPSBnbG9iYWxUaGlzO1xufSBlbHNlIHtcblx0dHJ5IHtcblx0XHRfZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJ2VzNS1leHQvZ2xvYmFsJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdH0gZmluYWxseSB7XG5cdFx0aWYgKCFfZ2xvYmFsVGhpcyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyBfZ2xvYmFsVGhpcyA9IHdpbmRvdzsgfVxuXHRcdGlmICghX2dsb2JhbFRoaXMpIHsgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGdsb2JhbCB0aGlzJyk7IH1cblx0fVxufVxuXG52YXIgTmF0aXZlV2ViU29ja2V0ID0gX2dsb2JhbFRoaXMuV2ViU29ja2V0IHx8IF9nbG9iYWxUaGlzLk1veldlYlNvY2tldDtcbnZhciB3ZWJzb2NrZXRfdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5cbi8qKlxuICogRXhwb3NlIGEgVzNDIFdlYlNvY2tldCBjbGFzcyB3aXRoIGp1c3Qgb25lIG9yIHR3byBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIFczQ1dlYlNvY2tldCh1cmksIHByb3RvY29scykge1xuXHR2YXIgbmF0aXZlX2luc3RhbmNlO1xuXG5cdGlmIChwcm90b2NvbHMpIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSk7XG5cdH1cblxuXHQvKipcblx0ICogJ25hdGl2ZV9pbnN0YW5jZScgaXMgYW4gaW5zdGFuY2Ugb2YgbmF0aXZlV2ViU29ja2V0ICh0aGUgYnJvd3NlcidzIFdlYlNvY2tldFxuXHQgKiBjbGFzcykuIFNpbmNlIGl0IGlzIGFuIE9iamVjdCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGl0IGlzIHdoZW4gY3JlYXRpbmcgYW5cblx0ICogaW5zdGFuY2Ugb2YgVzNDV2ViU29ja2V0IHZpYSAnbmV3IFczQ1dlYlNvY2tldCgpJy5cblx0ICpcblx0ICogRUNNQVNjcmlwdCA1OiBodHRwOi8vYmNsYXJ5LmNvbS8yMDA0LzExLzA3LyNhLTEzLjIuMlxuXHQgKi9cblx0cmV0dXJuIG5hdGl2ZV9pbnN0YW5jZTtcbn1cbmlmIChOYXRpdmVXZWJTb2NrZXQpIHtcblx0WydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTmF0aXZlV2ViU29ja2V0W3Byb3BdOyB9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAndzNjd2Vic29ja2V0JyA6IE5hdGl2ZVdlYlNvY2tldCA/IFczQ1dlYlNvY2tldCA6IG51bGwsXG4gICAgJ3ZlcnNpb24nICAgICAgOiB3ZWJzb2NrZXRfdmVyc2lvblxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==